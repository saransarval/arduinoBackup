CCS PCM C Compiler, Version 5.008, 5967               15-Feb-14 22:02

               Filename:   C:\Users\GRT-Embedded\Desktop\GLCD\test.lst

               ROM used:   695 words (8%)
                           Largest free fragment is 2048
               RAM used:   14 (4%) at main() level
                           35 (10%) worst case
               Stack used: 3 locations
               Stack size: 8

*
0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   26D
0003:  NOP
.................... #include<16f877a.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
*
0042:  CLRF   77
0043:  CLRF   78
0044:  MOVF   37,W
0045:  BCF    03.0
0046:  BTFSC  38.0
0047:  ADDWF  77,F
0048:  RRF    77,F
0049:  RRF    78,F
004A:  BTFSC  38.1
004B:  ADDWF  77,F
004C:  RRF    77,F
004D:  RRF    78,F
004E:  BTFSC  38.2
004F:  ADDWF  77,F
0050:  RRF    77,F
0051:  RRF    78,F
0052:  BTFSC  38.3
0053:  ADDWF  77,F
0054:  RRF    77,F
0055:  RRF    78,F
0056:  BTFSC  38.4
0057:  ADDWF  77,F
0058:  RRF    77,F
0059:  RRF    78,F
005A:  BTFSC  38.5
005B:  ADDWF  77,F
005C:  RRF    77,F
005D:  RRF    78,F
005E:  BTFSC  38.6
005F:  ADDWF  77,F
0060:  RRF    77,F
0061:  RRF    78,F
0062:  BTFSC  38.7
0063:  ADDWF  77,F
0064:  RRF    77,F
0065:  RRF    78,F
0066:  RETURN
....................  
.................... #list 
....................  
.................... #use delay(clock=11059200) 
*
0004:  MOVLW  29
0005:  MOVWF  04
0006:  BCF    03.7
0007:  MOVF   00,W
0008:  BTFSC  03.2
0009:  GOTO   017
000A:  MOVLW  03
000B:  MOVWF  78
000C:  CLRF   77
000D:  DECFSZ 77,F
000E:  GOTO   00D
000F:  DECFSZ 78,F
0010:  GOTO   00C
0011:  MOVLW  95
0012:  MOVWF  77
0013:  DECFSZ 77,F
0014:  GOTO   013
0015:  DECFSZ 00,F
0016:  GOTO   00A
0017:  RETURN
.................... #include "Header_GLCD.h" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           GLCD.C                                //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// an LED backlight. The HDM64GS12 is 128 pixles across and 64     //// 
.................... //// pixels down. The driver treats the upper left pixel as (0,0).   //// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0 - LCD operating voltage is connected from a 20k Ohm POT//// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1,y1,x2,y2,color)                                   //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color.                                     //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1,y1,x2,y2,fill,color)                              //// 
.................... ////     * Draws a rectangle with upper left point (x1,y1) and lower //// 
.................... ////       right point (x2,y2).                                      //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1,y1,x2,y2,width,color)                              //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point.                                             //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x,y,radius,fill,color)                             //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x,y,textptr,size,color)                            //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y).//// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall.           //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - The given text is character wrapped. If this       //// 
.................... ////       function is used on a different size display, then change //// 
.................... ////       the GLCD_WIDTH define appropriately.                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef GLCD_C 
.................... #define GLCD_C 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH 128    // Used for text wrapping by glcd_text57 function 
.................... #endif 
....................  
.................... #define ON  1 
.................... #define OFF 0 
....................  
.................... #define YES 1 
.................... #define NO  0 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1 PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2 PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI  PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW  PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E   PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST PIN_C0   // Reset 
.................... #endif 
....................  
....................  
....................  
.................... BYTE glcd_readByte(BYTE chip); 
.................... void glcd_writeByte(BYTE chip, BYTE data); 
.................... void glcd_fillScreen(int1 color); 
....................  
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
....................  
.................... // Purpose:       Initialize a graphic LCD. This must be called before any 
.................... //                other glcd function is used. 
.................... // Inputs:        The initialization mode 
.................... //                OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... // Date:          5/28/2003 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
00B0:  BCF    20.0
00B1:  MOVF   20,W
00B2:  BSF    03.5
00B3:  MOVWF  07
00B4:  BCF    03.5
00B5:  BSF    07.0
....................    output_low(GLCD_E); 
00B6:  BSF    03.5
00B7:  BCF    06.5
00B8:  BCF    03.5
00B9:  BCF    06.5
....................    output_low(GLCD_CS1); 
00BA:  BSF    03.5
00BB:  BCF    06.0
00BC:  BCF    03.5
00BD:  BCF    06.0
....................    output_low(GLCD_CS2); 
00BE:  BSF    03.5
00BF:  BCF    06.1
00C0:  BCF    03.5
00C1:  BCF    06.1
....................  
....................    output_low(GLCD_DI);                // Set for instruction 
00C2:  BSF    03.5
00C3:  BCF    06.2
00C4:  BCF    03.5
00C5:  BCF    06.2
....................    glcd_writeByte(GLCD_CS1, 0xC0);     // Specify first RAM line at the top 
00C6:  MOVLW  30
00C7:  MOVWF  3C
00C8:  MOVLW  C0
00C9:  MOVWF  3D
00CA:  CALL   018
....................    glcd_writeByte(GLCD_CS2, 0xC0);     //   of the screen 
00CB:  MOVLW  31
00CC:  MOVWF  3C
00CD:  MOVLW  C0
00CE:  MOVWF  3D
00CF:  CALL   018
....................    glcd_writeByte(GLCD_CS1, 0x40);     // Set the column address to 0 
00D0:  MOVLW  30
00D1:  MOVWF  3C
00D2:  MOVLW  40
00D3:  MOVWF  3D
00D4:  CALL   018
....................    glcd_writeByte(GLCD_CS2, 0x40); 
00D5:  MOVLW  31
00D6:  MOVWF  3C
00D7:  MOVLW  40
00D8:  MOVWF  3D
00D9:  CALL   018
....................    glcd_writeByte(GLCD_CS1, 0xB8);     // Set the page address to 0 
00DA:  MOVLW  30
00DB:  MOVWF  3C
00DC:  MOVLW  B8
00DD:  MOVWF  3D
00DE:  CALL   018
....................    glcd_writeByte(GLCD_CS2, 0xB8); 
00DF:  MOVLW  31
00E0:  MOVWF  3C
00E1:  MOVLW  B8
00E2:  MOVWF  3D
00E3:  CALL   018
....................    if(mode == ON) 
00E4:  DECFSZ 28,W
00E5:  GOTO   0F1
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3F);  // Turn the display on 
00E6:  MOVLW  30
00E7:  MOVWF  3C
00E8:  MOVLW  3F
00E9:  MOVWF  3D
00EA:  CALL   018
....................       glcd_writeByte(GLCD_CS2, 0x3F); 
00EB:  MOVLW  31
00EC:  MOVWF  3C
00ED:  MOVLW  3F
00EE:  MOVWF  3D
00EF:  CALL   018
....................    } 
00F0:  GOTO   0FB
....................    else 
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3E);  // Turn the display off 
00F1:  MOVLW  30
00F2:  MOVWF  3C
00F3:  MOVLW  3E
00F4:  MOVWF  3D
00F5:  CALL   018
....................       glcd_writeByte(GLCD_CS2, 0x3E); 
00F6:  MOVLW  31
00F7:  MOVWF  3C
00F8:  MOVLW  3E
00F9:  MOVWF  3D
00FA:  CALL   018
....................    } 
....................  
....................    glcd_fillScreen(OFF);               // Clear the display 
00FB:  CLRF   29
00FC:  CALL   067
00FD:  BCF    0A.3
00FE:  BCF    0A.4
00FF:  GOTO   28A (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:       Turn a pixel on a graphic LCD on or off 
.................... // Inputs:        x - the x coordinate of the pixel 
.................... //                y - the y coordinate of the pixel 
.................... //                color - ON or OFF 
.................... // Output:        1 if coordinate out of range, 0 if in range 
.................... void glcd_pixel(int x, int y, int1 color) 
0100:  MOVLW  30
0101:  MOVWF  3A
.................... { 
....................    BYTE data; 
....................    BYTE chip = GLCD_CS1;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)  // Check for first or second display area 
0102:  MOVF   36,W
0103:  SUBLW  3F
0104:  BTFSC  03.0
0105:  GOTO   10A
....................    { 
....................       x -= 64; 
0106:  MOVLW  40
0107:  SUBWF  36,F
....................       chip = GLCD_CS2; 
0108:  MOVLW  31
0109:  MOVWF  3A
....................    } 
....................  
....................    output_low(GLCD_DI);                                     // Set for instruction 
010A:  BSF    03.5
010B:  BCF    06.2
010C:  BCF    03.5
010D:  BCF    06.2
....................    bit_clear(x,7);                                          // Clear the MSB. Part of an instruction code 
010E:  BCF    36.7
....................    bit_set(x,6);                                            // Set bit 6. Also part of an instruction code 
010F:  BSF    36.6
....................    glcd_writeByte(chip, x);                                 // Set the horizontal address 
0110:  MOVF   3A,W
0111:  MOVWF  3C
0112:  MOVF   36,W
0113:  MOVWF  3D
0114:  CALL   018
....................    glcd_writeByte(chip, (y/8 & 0b10111111) | 0b10111000);   // Set the vertical page address 
0115:  RRF    37,W
0116:  MOVWF  77
0117:  RRF    77,F
0118:  RRF    77,F
0119:  MOVLW  1F
011A:  ANDWF  77,F
011B:  MOVF   77,W
011C:  ANDLW  BF
011D:  IORLW  B8
011E:  MOVWF  3B
011F:  MOVF   3A,W
0120:  MOVWF  3C
0121:  MOVF   3B,W
0122:  MOVWF  3D
0123:  CALL   018
....................    output_high(GLCD_DI);                                    // Set for data 
0124:  BSF    03.5
0125:  BCF    06.2
0126:  BCF    03.5
0127:  BSF    06.2
....................    data = glcd_readByte(chip); 
0128:  MOVF   3A,W
0129:  MOVWF  3B
*
0166:  MOVF   78,W
0167:  MOVWF  39
....................  
....................    if(color == ON) 
0168:  DECFSZ 38,W
0169:  GOTO   17A
....................       bit_set(data, y%8);        // Turn the pixel on 
016A:  MOVF   37,W
016B:  ANDLW  07
016C:  MOVWF  3B
016D:  MOVLW  01
016E:  MOVWF  77
016F:  MOVF   3B,W
0170:  MOVWF  78
0171:  BTFSC  03.2
0172:  GOTO   177
0173:  BCF    03.0
0174:  RLF    77,F
0175:  DECFSZ 78,F
0176:  GOTO   173
0177:  MOVF   77,W
0178:  IORWF  39,F
0179:  GOTO   18A
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
017A:  MOVF   37,W
017B:  ANDLW  07
017C:  MOVWF  3B
017D:  MOVLW  01
017E:  MOVWF  77
017F:  MOVF   3B,W
0180:  MOVWF  78
0181:  BTFSC  03.2
0182:  GOTO   187
0183:  BCF    03.0
0184:  RLF    77,F
0185:  DECFSZ 78,F
0186:  GOTO   183
0187:  MOVF   77,W
0188:  XORLW  FF
0189:  ANDWF  39,F
....................    output_low(GLCD_DI);          // Set for instruction 
018A:  BSF    03.5
018B:  BCF    06.2
018C:  BCF    03.5
018D:  BCF    06.2
....................    glcd_writeByte(chip, x);      // Set the horizontal address 
018E:  MOVF   3A,W
018F:  MOVWF  3C
0190:  MOVF   36,W
0191:  MOVWF  3D
0192:  CALL   018
....................    output_high(GLCD_DI);         // Set for data 
0193:  BSF    03.5
0194:  BCF    06.2
0195:  BCF    03.5
0196:  BSF    06.2
....................    glcd_writeByte(chip, data);   // Write the pixel data 
0197:  MOVF   3A,W
0198:  MOVWF  3C
0199:  MOVF   39,W
019A:  MOVWF  3D
019B:  CALL   018
019C:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
019D:  MOVF   28,W
019E:  SUBWF  2A,W
019F:  MOVWF  36
01A0:  MOVF   36,W
01A1:  BTFSS  36.7
01A2:  GOTO   1A5
01A3:  MOVF   36,W
01A4:  SUBLW  00
01A5:  MOVWF  31
....................    dy = abs((signed int)(y2 - y1)); 
01A6:  MOVF   29,W
01A7:  SUBWF  2B,W
01A8:  MOVWF  36
01A9:  MOVF   36,W
01AA:  BTFSS  36.7
01AB:  GOTO   1AE
01AC:  MOVF   36,W
01AD:  SUBLW  00
01AE:  MOVWF  32
....................    x = x1; 
01AF:  MOVF   28,W
01B0:  MOVWF  2D
....................    y = y1; 
01B1:  MOVF   29,W
01B2:  MOVWF  2E
....................  
....................    if(x1 > x2) 
01B3:  MOVF   28,W
01B4:  SUBWF  2A,W
01B5:  BTFSC  03.0
01B6:  GOTO   1BA
....................       addx = -1; 
01B7:  MOVLW  FF
01B8:  MOVWF  2F
01B9:  GOTO   1BC
....................    else 
....................       addx = 1; 
01BA:  MOVLW  01
01BB:  MOVWF  2F
....................    if(y1 > y2) 
01BC:  MOVF   29,W
01BD:  SUBWF  2B,W
01BE:  BTFSC  03.0
01BF:  GOTO   1C3
....................       addy = -1; 
01C0:  MOVLW  FF
01C1:  MOVWF  30
01C2:  GOTO   1C5
....................    else 
....................       addy = 1; 
01C3:  MOVLW  01
01C4:  MOVWF  30
....................  
....................    if(dx >= dy) 
01C5:  MOVF   32,W
01C6:  XORLW  80
01C7:  MOVWF  77
01C8:  MOVF   31,W
01C9:  XORLW  80
01CA:  SUBWF  77,W
01CB:  BTFSC  03.2
01CC:  GOTO   1CF
01CD:  BTFSC  03.0
01CE:  GOTO   21D
....................    { 
....................       P = 2*dy - dx; 
01CF:  MOVLW  02
01D0:  MOVWF  37
01D1:  MOVF   32,W
01D2:  MOVWF  38
01D3:  CALL   042
01D4:  MOVF   31,W
01D5:  SUBWF  78,W
01D6:  CLRF   7A
01D7:  MOVWF  77
01D8:  BTFSC  77.7
01D9:  DECF   7A,F
01DA:  MOVWF  33
01DB:  MOVF   7A,W
01DC:  MOVWF  34
....................  
....................       for(i=0; i<=dx; ++i) 
01DD:  CLRF   35
01DE:  BTFSC  31.7
01DF:  GOTO   21C
01E0:  MOVF   35,W
01E1:  SUBWF  31,W
01E2:  BTFSS  03.0
01E3:  GOTO   21C
....................       { 
....................          glcd_pixel(x, y, color); 
01E4:  MOVF   2D,W
01E5:  MOVWF  36
01E6:  MOVF   2E,W
01E7:  MOVWF  37
01E8:  MOVF   2C,W
01E9:  MOVWF  38
01EA:  CALL   100
....................  
....................          if(P < 0) 
01EB:  BTFSS  34.7
01EC:  GOTO   1FF
....................          { 
....................             P += 2*dy; 
01ED:  MOVLW  02
01EE:  MOVWF  37
01EF:  MOVF   32,W
01F0:  MOVWF  38
01F1:  CALL   042
01F2:  MOVF   78,W
01F3:  CLRF   7A
01F4:  MOVWF  77
01F5:  BTFSC  77.7
01F6:  DECF   7A,F
01F7:  ADDWF  33,F
01F8:  MOVF   7A,W
01F9:  BTFSC  03.0
01FA:  INCFSZ 7A,W
01FB:  ADDWF  34,F
....................             x += addx; 
01FC:  MOVF   2F,W
01FD:  ADDWF  2D,F
....................          } 
01FE:  GOTO   21A
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
01FF:  MOVLW  02
0200:  MOVWF  37
0201:  MOVF   32,W
0202:  MOVWF  38
0203:  CALL   042
0204:  MOVF   78,W
0205:  MOVWF  36
0206:  MOVLW  02
0207:  MOVWF  37
0208:  MOVF   31,W
0209:  MOVWF  38
020A:  CALL   042
020B:  MOVF   78,W
020C:  SUBWF  36,W
020D:  CLRF   7A
020E:  MOVWF  77
020F:  BTFSC  77.7
0210:  DECF   7A,F
0211:  ADDWF  33,F
0212:  MOVF   7A,W
0213:  BTFSC  03.0
0214:  INCFSZ 7A,W
0215:  ADDWF  34,F
....................             x += addx; 
0216:  MOVF   2F,W
0217:  ADDWF  2D,F
....................             y += addy; 
0218:  MOVF   30,W
0219:  ADDWF  2E,F
....................          } 
021A:  INCF   35,F
021B:  GOTO   1DE
....................       } 
....................    } 
021C:  GOTO   26A
....................    else 
....................    { 
....................       P = 2*dx - dy; 
021D:  MOVLW  02
021E:  MOVWF  37
021F:  MOVF   31,W
0220:  MOVWF  38
0221:  CALL   042
0222:  MOVF   32,W
0223:  SUBWF  78,W
0224:  CLRF   7A
0225:  MOVWF  77
0226:  BTFSC  77.7
0227:  DECF   7A,F
0228:  MOVWF  33
0229:  MOVF   7A,W
022A:  MOVWF  34
....................  
....................       for(i=0; i<=dy; ++i) 
022B:  CLRF   35
022C:  BTFSC  32.7
022D:  GOTO   26A
022E:  MOVF   35,W
022F:  SUBWF  32,W
0230:  BTFSS  03.0
0231:  GOTO   26A
....................       { 
....................          glcd_pixel(x, y, color); 
0232:  MOVF   2D,W
0233:  MOVWF  36
0234:  MOVF   2E,W
0235:  MOVWF  37
0236:  MOVF   2C,W
0237:  MOVWF  38
0238:  CALL   100
....................  
....................          if(P < 0) 
0239:  BTFSS  34.7
023A:  GOTO   24D
....................          { 
....................             P += 2*dx; 
023B:  MOVLW  02
023C:  MOVWF  37
023D:  MOVF   31,W
023E:  MOVWF  38
023F:  CALL   042
0240:  MOVF   78,W
0241:  CLRF   7A
0242:  MOVWF  77
0243:  BTFSC  77.7
0244:  DECF   7A,F
0245:  ADDWF  33,F
0246:  MOVF   7A,W
0247:  BTFSC  03.0
0248:  INCFSZ 7A,W
0249:  ADDWF  34,F
....................             y += addy; 
024A:  MOVF   30,W
024B:  ADDWF  2E,F
....................          } 
024C:  GOTO   268
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
024D:  MOVLW  02
024E:  MOVWF  37
024F:  MOVF   31,W
0250:  MOVWF  38
0251:  CALL   042
0252:  MOVF   78,W
0253:  MOVWF  36
0254:  MOVLW  02
0255:  MOVWF  37
0256:  MOVF   32,W
0257:  MOVWF  38
0258:  CALL   042
0259:  MOVF   78,W
025A:  SUBWF  36,W
025B:  CLRF   7A
025C:  MOVWF  77
025D:  BTFSC  77.7
025E:  DECF   7A,F
025F:  ADDWF  33,F
0260:  MOVF   7A,W
0261:  BTFSC  03.0
0262:  INCFSZ 7A,W
0263:  ADDWF  34,F
....................             x += addx; 
0264:  MOVF   2F,W
0265:  ADDWF  2D,F
....................             y += addy; 
0266:  MOVF   30,W
0267:  ADDWF  2E,F
....................          } 
0268:  INCF   35,F
0269:  GOTO   22C
....................       } 
....................    } 
026A:  BCF    0A.3
026B:  BCF    0A.4
026C:  GOTO   29E (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... void glcd_rect(int x1, int y1, int x2, int y2, int fill, int1 color) 
.................... { 
....................    if(fill) 
....................    { 
....................       int y, ymax;                          // Find the y min and max 
....................       if(y1 < y2) 
....................       { 
....................          y = y1; 
....................          ymax = y2; 
....................       } 
....................       else 
....................       { 
....................          y = y2; 
....................          ymax = y1; 
....................       } 
....................  
....................       for(; y<=ymax; ++y)                    // Draw lines to fill the rectangle 
....................          glcd_line(x1, y, x2, y, color); 
....................    } 
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
....................       glcd_line(x1, y2, x2, y2, color); 
....................       glcd_line(x1, y1, x1, y2, color); 
....................       glcd_line(x2, y1, x2, y2, color); 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... void glcd_bar(int x1, int y1, int x2, int y2, int width, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, j; 
....................    signed long P, dx, dy, c1, c2; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................    c1 = -dx*x1 - dy*y1; 
....................    c2 = -dx*x2 - dy*y2; 
....................  
....................    if(x1 > x2) 
....................    { 
....................       addx = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................    { 
....................       addy = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addy = 1; 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x, y+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x+j, y, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... void glcd_circle(int x, int y, int radius, int1 fill, int1 color) 
.................... { 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... void glcd_text57(int x, int y, char* textptr, int size, int1 color) 
.................... { 
....................    int i, j, k, l, m;                     // Loop counters 
....................    BYTE pixelData[5];                     // Stores character data 
....................  
....................    for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string 
....................    { 
....................       if(textptr[i] < 'S') // Checks if the letter is in the first text array 
....................          memcpy(pixelData, TEXT[textptr[i]-' '], 5); 
....................       else if(textptr[i] <= '~') // Check if the letter is in the second array 
....................          memcpy(pixelData, TEXT2[textptr[i]-'S'], 5); 
....................       else 
....................          memcpy(pixelData, TEXT[0], 5);   // Default to space 
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
....................       { 
....................          x = 0;                           // Set x at far left position 
....................          y += 7*size + 1;                 // Set y at next position down 
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
....................       { 
....................          for(k=0; k<7*size; ++k)          // Loop through the vertical pixels 
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
....................             { 
....................                for(l=0; l<size; ++l)      // The next two loops change the 
....................                {                          // character's size 
....................                   for(m=0; m<size; ++m) 
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
....................                   } 
....................                } 
....................             } 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Fill the LCD screen with the passed in color. 
.................... //                Works much faster than drawing a rectangle to fill the screen. 
.................... // Inputs:        ON - turn all the pixels on 
.................... //                OFF - turn all the pixels off 
.................... // Dependencies:  glcd_writeByte() 
.................... void glcd_fillScreen(int1 color) 
.................... { 
....................    int i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
0067:  CLRF   2A
0068:  MOVF   2A,W
0069:  SUBLW  07
006A:  BTFSS  03.0
006B:  GOTO   0AF
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
006C:  BSF    03.5
006D:  BCF    06.2
006E:  BCF    03.5
006F:  BCF    06.2
....................       glcd_writeByte(GLCD_CS1, 0b01000000);     // Set horizontal address to 0 
0070:  MOVLW  30
0071:  MOVWF  3C
0072:  MOVLW  40
0073:  MOVWF  3D
0074:  CALL   018
....................       glcd_writeByte(GLCD_CS2, 0b01000000); 
0075:  MOVLW  31
0076:  MOVWF  3C
0077:  MOVLW  40
0078:  MOVWF  3D
0079:  CALL   018
....................       glcd_writeByte(GLCD_CS1, i | 0b10111000); // Set page address 
007A:  MOVF   2A,W
007B:  IORLW  B8
007C:  MOVWF  2C
007D:  MOVLW  30
007E:  MOVWF  3C
007F:  MOVF   2C,W
0080:  MOVWF  3D
0081:  CALL   018
....................       glcd_writeByte(GLCD_CS2, i | 0b10111000); 
0082:  MOVF   2A,W
0083:  IORLW  B8
0084:  MOVWF  2C
0085:  MOVLW  31
0086:  MOVWF  3C
0087:  MOVF   2C,W
0088:  MOVWF  3D
0089:  CALL   018
....................       output_high(GLCD_DI);                     // Set for data 
008A:  BSF    03.5
008B:  BCF    06.2
008C:  BCF    03.5
008D:  BSF    06.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
008E:  CLRF   2B
008F:  MOVF   2B,W
0090:  SUBLW  3F
0091:  BTFSS  03.0
0092:  GOTO   0AD
....................       { 
....................          glcd_writeByte(GLCD_CS1, 0xFF*color);  // Turn pixels on or off 
0093:  MOVLW  FF
0094:  MOVWF  37
0095:  MOVF   29,W
0096:  MOVWF  38
0097:  CALL   042
0098:  MOVF   78,W
0099:  MOVWF  2C
009A:  MOVLW  30
009B:  MOVWF  3C
009C:  MOVF   78,W
009D:  MOVWF  3D
009E:  CALL   018
....................          glcd_writeByte(GLCD_CS2, 0xFF*color);  // Turn pixels on or off 
009F:  MOVLW  FF
00A0:  MOVWF  37
00A1:  MOVF   29,W
00A2:  MOVWF  38
00A3:  CALL   042
00A4:  MOVF   78,W
00A5:  MOVWF  2C
00A6:  MOVLW  31
00A7:  MOVWF  3C
00A8:  MOVF   78,W
00A9:  MOVWF  3D
00AA:  CALL   018
00AB:  INCF   2B,F
00AC:  GOTO   08F
....................       } 
00AD:  INCF   2A,F
00AE:  GOTO   068
....................    } 
00AF:  RETURN
.................... } 
....................  
.................... // Purpose:       Write a byte of data to the specified chip 
.................... // Inputs:        chipSelect - which chip to write the data to 
.................... //                data - the byte of data to write 
....................  
.................... void glcd_writeByte(char chip, BYTE data) 
.................... { 
....................    if(chip == GLCD_CS1)       // Choose which chip to write to 
*
0018:  MOVF   3C,W
0019:  SUBLW  30
001A:  BTFSS  03.2
001B:  GOTO   021
....................       output_high(GLCD_CS1); 
001C:  BSF    03.5
001D:  BCF    06.0
001E:  BCF    03.5
001F:  BSF    06.0
0020:  GOTO   025
....................    else 
....................       output_high(GLCD_CS2); 
0021:  BSF    03.5
0022:  BCF    06.1
0023:  BCF    03.5
0024:  BSF    06.1
....................  
....................    output_low(GLCD_RW);       // Set for writing 
0025:  BSF    03.5
0026:  BCF    06.4
0027:  BCF    03.5
0028:  BCF    06.4
....................    output_d(data);            // Put the data on the port 
0029:  BSF    03.5
002A:  CLRF   08
002B:  BCF    03.5
002C:  MOVF   3D,W
002D:  MOVWF  08
....................    output_high(GLCD_E);       // Pulse the enable pin 
002E:  BSF    03.5
002F:  BCF    06.5
0030:  BCF    03.5
0031:  BSF    06.5
....................    delay_us(2); 
0032:  GOTO   033
0033:  GOTO   034
0034:  NOP
....................    output_low(GLCD_E); 
0035:  BSF    03.5
0036:  BCF    06.5
0037:  BCF    03.5
0038:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
0039:  BSF    03.5
003A:  BCF    06.0
003B:  BCF    03.5
003C:  BCF    06.0
....................    output_low(GLCD_CS2); 
003D:  BSF    03.5
003E:  BCF    06.1
003F:  BCF    03.5
0040:  BCF    06.1
0041:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Reads a byte of data from the specified chip 
.................... // Ouputs:        A byte of data read from the chip 
.................... BYTE glcd_readByte(BYTE chip) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................    if(chip == GLCD_CS1)       // Choose which chip to read from 
*
012A:  MOVF   3B,W
012B:  SUBLW  30
012C:  BTFSS  03.2
012D:  GOTO   133
....................       output_high(GLCD_CS1); 
012E:  BSF    03.5
012F:  BCF    06.0
0130:  BCF    03.5
0131:  BSF    06.0
0132:  GOTO   137
....................    else 
....................       output_high(GLCD_CS2); 
0133:  BSF    03.5
0134:  BCF    06.1
0135:  BCF    03.5
0136:  BSF    06.1
....................  
....................    input_d();                 // Set port d to input 
0137:  MOVLW  FF
0138:  BSF    03.5
0139:  MOVWF  08
....................    output_high(GLCD_RW);      // Set for reading 
013A:  BCF    06.4
013B:  BCF    03.5
013C:  BSF    06.4
....................    output_high(GLCD_E);       // Pulse the enable pin 
013D:  BSF    03.5
013E:  BCF    06.5
013F:  BCF    03.5
0140:  BSF    06.5
....................    delay_us(2); 
0141:  GOTO   142
0142:  GOTO   143
0143:  NOP
....................    output_low(GLCD_E); 
0144:  BSF    03.5
0145:  BCF    06.5
0146:  BCF    03.5
0147:  BCF    06.5
....................    delay_us(2); 
0148:  GOTO   149
0149:  GOTO   14A
014A:  NOP
....................    output_high(GLCD_E);       // Pulse the enable pin 
014B:  BSF    03.5
014C:  BCF    06.5
014D:  BCF    03.5
014E:  BSF    06.5
....................    delay_us(2); 
014F:  GOTO   150
0150:  GOTO   151
0151:  NOP
....................    data = input_d();          // Get the data from the display's output register 
0152:  MOVLW  FF
0153:  BSF    03.5
0154:  MOVWF  08
0155:  BCF    03.5
0156:  MOVF   08,W
0157:  MOVWF  3C
....................    output_low(GLCD_E); 
0158:  BSF    03.5
0159:  BCF    06.5
015A:  BCF    03.5
015B:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
015C:  BSF    03.5
015D:  BCF    06.0
015E:  BCF    03.5
015F:  BCF    06.0
....................    output_low(GLCD_CS2); 
0160:  BSF    03.5
0161:  BCF    06.1
0162:  BCF    03.5
0163:  BCF    06.1
....................    return data;               // Return the read data 
0164:  MOVF   3C,W
0165:  MOVWF  78
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #byte trisc=0x87 
.................... #byte trisd=0x88 
.................... #byte trise=0x89 
.................... #byte trisb=0x86 
.................... #byte portd=0x08 
.................... #byte porte=0x09 
.................... #byte portb=0x06 
.................... #byte portc=0x07 
....................  
....................  
....................  
.................... unsigned int i; 
.................... int j,b,c,d,nam1; 
.................... int a=0; 
....................  
.................... /*void funct(unsigned int nam1,int i) 
.................... { 
....................    int j1=0,k; 
....................    for(j=0;j<i;j++) 
....................    { 
....................    if(j>=128)j1=j%128; 
....................    nam1=*nam1; 
....................    for(k=0;k<=8;k++) 
....................       { 
....................       d=(d*8)+k; 
....................       b=0x01<<k; 
....................       if(nam1&b)glcd_pixel(j,d,on); 
....................       else glcd_pixel(c,d,off); 
....................       } 
....................    } 
.................... }*/ 
....................  
.................... void main() 
*
026D:  MOVF   03,W
026E:  ANDLW  1F
026F:  MOVWF  03
0270:  MOVLW  FF
0271:  MOVWF  20
0272:  CLRF   27
0273:  BSF    03.5
0274:  BSF    1F.0
0275:  BSF    1F.1
0276:  BSF    1F.2
0277:  BCF    1F.3
0278:  MOVLW  07
0279:  MOVWF  1C
027A:  BCF    03.7
....................    { 
....................     
....................    trisc = 0x00; 
027B:  CLRF   07
....................    trisd=0x00; 
027C:  CLRF   08
....................    trisb=0x00; 
027D:  CLRF   06
....................    trise=0x00; 
027E:  CLRF   09
....................    delay_ms(500); 
027F:  MOVLW  02
0280:  BCF    03.5
0281:  MOVWF  28
0282:  MOVLW  FA
0283:  MOVWF  29
0284:  CALL   004
0285:  DECFSZ 28,F
0286:  GOTO   282
....................    glcd_init(on); 
0287:  MOVLW  01
0288:  MOVWF  28
0289:  GOTO   0B0
....................    delay_ms(500); 
028A:  MOVLW  02
028B:  MOVWF  28
028C:  MOVLW  FA
028D:  MOVWF  29
028E:  CALL   004
028F:  DECFSZ 28,F
0290:  GOTO   28C
....................    a=1; 
0291:  MOVLW  01
0292:  MOVWF  27
....................    while(1) 
....................       { 
....................  
....................       glcd_line(10,16,87,48,on); 
0293:  MOVLW  0A
0294:  MOVWF  28
0295:  MOVLW  10
0296:  MOVWF  29
0297:  MOVLW  57
0298:  MOVWF  2A
0299:  MOVLW  30
029A:  MOVWF  2B
029B:  MOVLW  01
029C:  MOVWF  2C
029D:  GOTO   19D
....................    delay_ms(500); 
029E:  MOVLW  02
029F:  MOVWF  28
02A0:  MOVLW  FA
02A1:  MOVWF  29
02A2:  CALL   004
02A3:  DECFSZ 28,F
02A4:  GOTO   2A0
....................        glcd_pixel(6,6,on); 
02A5:  MOVLW  06
02A6:  MOVWF  36
02A7:  MOVWF  37
02A8:  MOVLW  01
02A9:  MOVWF  38
02AA:  CALL   100
....................        glcd_fillScreen(on); 
02AB:  MOVLW  01
02AC:  MOVWF  29
02AD:  CALL   067
....................      //  glcd_text57(40,30,name,1,on); 
....................  
....................       delay_ms(500); 
02AE:  MOVLW  02
02AF:  MOVWF  28
02B0:  MOVLW  FA
02B1:  MOVWF  29
02B2:  CALL   004
02B3:  DECFSZ 28,F
02B4:  GOTO   2B0
02B5:  GOTO   293
....................        
....................       } 
....................  
....................    } 
02B6:  SLEEP

Configuration Fuses:
   Word  1: 3F73   RC NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
