CCS PCM C Compiler, Version 3.249, 33340               23-Sep-13 17:37

               Filename: \\GRT-EMBEDDED-PC\Users\Public\GRT SHARE_DOC\WORK_SHOP_DETAILS\KCT embedded system workshop\CD INCLUSIONS\PROGRAMS\LCD\LCD.lst

               ROM used: 363 words (4%)
                         Largest free fragment is 2048
               RAM used: 7 (4%) at main() level
                         17 (10%) worst case
               Stack:    3 locations

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   14A
0003:  NOP
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////////////// ************* GRT EMBEDDED SOLUITIONS ************ ///////////// 
.................... //***************************************************************************// 
....................              //THIS PROGRAM IS DEVELOPED USING CCS COMPILER DEMO VERSION// 
.................... //***************************************************************************/// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #INCLUDE<16F876A.H>                          ////////////// HEADER FILE///////// 
.................... //////// Standard Header file for the PIC16F876A device //////////////// 
.................... #device PIC16F876A 
.................... #list 
....................  
.................... #USE DELAY(CLOCK=11059200)                   /// DELAY FUNCTION (PRE DEFINED) // 
001F:  MOVLW  23
0020:  MOVWF  04
0021:  MOVF   00,W
0022:  BTFSC  03.2
0023:  GOTO   031
0024:  MOVLW  03
0025:  MOVWF  78
0026:  CLRF   77
0027:  DECFSZ 77,F
0028:  GOTO   027
0029:  DECFSZ 78,F
002A:  GOTO   026
002B:  MOVLW  95
002C:  MOVWF  77
002D:  DECFSZ 77,F
002E:  GOTO   02D
002F:  DECFSZ 00,F
0030:  GOTO   024
0031:  RETLW  00
....................  
....................  
.................... //////////////////////////////////////////////// 
.................... //////////////////////////////////////////////// 
.................... ///////  REFERING THE REGISTER ADDRESS ///////// 
.................... //////////////////////////////////////////////// 
.................... //////////////////////////////////////////////// 
....................  
.................... #BYTE TRISA=0X85 
.................... #BYTE TRISB=0X86 
.................... #BYTE TRISC=0X87 
....................  
.................... #BYTE PORTA=0X05 
.................... #BYTE PORTB=0X06 
.................... #BYTE PORTC=0X07 
....................  
.................... #INCLUDE<LCD.H>                        /// INCLUDE THIS HEADER IN  THE PROJECT FILE TO BE CREATED 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////////////// ************* GRT EMBEDDED SOLUITIONS ************ ///////////// 
.................... //***************************************************************************// 
....................              //THIS PROGRAM IS DEVELOPED USING CCS COMPILER DEMO VERSION// 
.................... //***************************************************************************/// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... //////////////////////////////////////////////// 
.................... //////////////////////////////////////////////// 
.................... ///////  LCD PIN ON THE ROBO KIT       ///////// 
.................... //////////////////////////////////////////////// 
.................... //////////////////////////////////////////////// 
....................  
....................  
.................... #define LCD_DB4   PIN_C0 
.................... #define LCD_DB5   PIN_C1 
.................... #define LCD_DB6   PIN_C2 
.................... #define LCD_DB7   PIN_C3 
....................  
.................... #define LCD_E     PIN_C5   ///////// USE JUMPER TO CONNECT, FOR EXAMPLE WE HAVE CONNECTED 
.................... #define LCD_RS    PIN_C4   ///////// C4 AND C5 TO RUN THIS PROGRAM 
.................... //#define LCD_RW    PIN_A1   ///////// THIS PIN IS GROUNDED IN THE BOARD 
....................  
.................... // If you only want a 6-pin interface to your LCD, then 
.................... // connect the R/W pin on the LCD to ground, and comment 
.................... // out the following line. 
....................  
.................... #define USE_LCD_RW   1      
....................  
.................... //======================================== 
....................  
.................... #define lcd_type 2        // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x80 // LCD RAM address for the 2nd line 
....................  
....................  
.................... int8 const LCD_INIT_STRING[4] = 
.................... { 
....................  0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots 
....................  0xc,                    // Display on 
....................  1,                      // Clear display 
....................  6                       // Increment cursor 
.................... }; 
....................  
....................  
.................... //------------------------------------- 
.................... void lcd_send_nibble(int8 nibble) 
.................... { 
.................... // Note:  !! converts an integer expression 
.................... // to a boolean (1 or 0). 
....................  output_bit(LCD_DB4, !!(nibble & 1)); 
0032:  BTFSC  2A.0
0033:  GOTO   036
0034:  BCF    07.0
0035:  GOTO   037
0036:  BSF    07.0
0037:  BCF    20.0
0038:  MOVF   20,W
0039:  BSF    03.5
003A:  MOVWF  07
*
0154:  MOVLW  FF
0155:  BCF    03.5
0156:  MOVWF  20
....................  output_bit(LCD_DB5, !!(nibble & 2));  
*
003B:  BCF    03.5
003C:  BTFSC  2A.1
003D:  GOTO   040
003E:  BCF    07.1
003F:  GOTO   041
0040:  BSF    07.1
0041:  BCF    20.1
0042:  MOVF   20,W
0043:  BSF    03.5
0044:  MOVWF  07
....................  output_bit(LCD_DB6, !!(nibble & 4));    
0045:  BCF    03.5
0046:  BTFSC  2A.2
0047:  GOTO   04A
0048:  BCF    07.2
0049:  GOTO   04B
004A:  BSF    07.2
004B:  BCF    20.2
004C:  MOVF   20,W
004D:  BSF    03.5
004E:  MOVWF  07
....................  output_bit(LCD_DB7, !!(nibble & 8));    
004F:  BCF    03.5
0050:  BTFSC  2A.3
0051:  GOTO   054
0052:  BCF    07.3
0053:  GOTO   055
0054:  BSF    07.3
0055:  BCF    20.3
0056:  MOVF   20,W
0057:  BSF    03.5
0058:  MOVWF  07
....................  
....................  delay_cycles(1); 
0059:  NOP
....................  output_high(LCD_E); 
005A:  BCF    03.5
005B:  BCF    20.5
005C:  MOVF   20,W
005D:  BSF    03.5
005E:  MOVWF  07
005F:  BCF    03.5
0060:  BSF    07.5
....................  delay_us(2); 
0061:  NOP
0062:  NOP
0063:  NOP
0064:  NOP
0065:  NOP
....................  output_low(LCD_E); 
0066:  BCF    20.5
0067:  MOVF   20,W
0068:  BSF    03.5
0069:  MOVWF  07
006A:  BCF    03.5
006B:  BCF    07.5
.................... } 
006C:  RETLW  00
....................  
.................... //----------------------------------- 
.................... // This sub-routine is only called by lcd_read_byte(). 
.................... // It's not a stand-alone routine.  For example, the 
.................... // R/W signal is set high by lcd_read_byte() before 
.................... // this routine is called.      
....................  
.................... #ifdef USE_LCD_RW 
.................... int8 lcd_read_nibble(void) 
.................... { 
.................... int8 retval; 
.................... // Create bit variables so that we can easily set 
.................... // individual bits in the retval variable. 
.................... #bit retval_0 = retval.0 
.................... #bit retval_1 = retval.1 
.................... #bit retval_2 = retval.2 
.................... #bit retval_3 = retval.3 
....................  
.................... retval = 0; 
006D:  CLRF   2B
....................  
.................... output_high(LCD_E); 
006E:  BCF    20.5
006F:  MOVF   20,W
0070:  BSF    03.5
0071:  MOVWF  07
0072:  BCF    03.5
0073:  BSF    07.5
.................... delay_cycles(1); 
0074:  NOP
....................  
.................... retval_0 = input(LCD_DB4); 
0075:  BSF    20.0
0076:  MOVF   20,W
0077:  BSF    03.5
0078:  MOVWF  07
0079:  BCF    03.5
007A:  BTFSC  07.0
007B:  GOTO   07E
007C:  BCF    2B.0
007D:  GOTO   07F
007E:  BSF    2B.0
.................... retval_1 = input(LCD_DB5); 
007F:  BSF    20.1
0080:  MOVF   20,W
0081:  BSF    03.5
0082:  MOVWF  07
0083:  BCF    03.5
0084:  BTFSC  07.1
0085:  GOTO   088
0086:  BCF    2B.1
0087:  GOTO   089
0088:  BSF    2B.1
.................... retval_2 = input(LCD_DB6); 
0089:  BSF    20.2
008A:  MOVF   20,W
008B:  BSF    03.5
008C:  MOVWF  07
008D:  BCF    03.5
008E:  BTFSC  07.2
008F:  GOTO   092
0090:  BCF    2B.2
0091:  GOTO   093
0092:  BSF    2B.2
.................... retval_3 = input(LCD_DB7); 
0093:  BSF    20.3
0094:  MOVF   20,W
0095:  BSF    03.5
0096:  MOVWF  07
0097:  BCF    03.5
0098:  BTFSC  07.3
0099:  GOTO   09C
009A:  BCF    2B.3
009B:  GOTO   09D
009C:  BSF    2B.3
....................  
.................... output_low(LCD_E); 
009D:  BCF    20.5
009E:  MOVF   20,W
009F:  BSF    03.5
00A0:  MOVWF  07
00A1:  BCF    03.5
00A2:  BCF    07.5
....................  
.................... return(retval);    
00A3:  MOVF   2B,W
00A4:  MOVWF  78
.................... }    
00A5:  RETLW  00
.................... #endif 
....................  
.................... //--------------------------------------- 
.................... // Read a byte from the LCD and return it. 
....................  
.................... #ifdef USE_LCD_RW 
.................... int8 lcd_read_byte(void) 
.................... { 
.................... int8 low; 
.................... int8 high; 
....................  
.................... //output_high(LCD_RW); 
.................... delay_cycles(1); 
*
00AC:  NOP
....................  
.................... high = lcd_read_nibble(); 
00AD:  CALL   06D
00AE:  MOVF   78,W
00AF:  MOVWF  2A
....................  
.................... low = lcd_read_nibble(); 
00B0:  CALL   06D
00B1:  MOVF   78,W
00B2:  MOVWF  29
....................  
.................... return( (high<<4) | low); 
00B3:  SWAPF  2A,W
00B4:  MOVWF  77
00B5:  MOVLW  F0
00B6:  ANDWF  77,F
00B7:  MOVF   77,W
00B8:  IORWF  29,W
00B9:  MOVWF  78
.................... } 
.................... #endif 
....................  
.................... //---------------------------------------- 
.................... // Send a byte to the LCD. 
.................... void lcd_send_byte(int8 address, int8 n) 
.................... { 
.................... output_low(LCD_RS); 
*
00A6:  BCF    20.4
00A7:  MOVF   20,W
00A8:  BSF    03.5
00A9:  MOVWF  07
00AA:  BCF    03.5
00AB:  BCF    07.4
....................  
.................... #ifdef USE_LCD_RW 
.................... while(bit_test(lcd_read_byte(),7)) ; 
*
00BA:  MOVF   78,W
00BB:  MOVWF  29
00BC:  BTFSC  29.7
00BD:  GOTO   0AC
.................... #else 
.................... delay_us(60);  
.................... #endif 
....................  
.................... if(address) 
00BE:  MOVF   27,F
00BF:  BTFSC  03.2
00C0:  GOTO   0C8
....................    output_high(LCD_RS); 
00C1:  BCF    20.4
00C2:  MOVF   20,W
00C3:  BSF    03.5
00C4:  MOVWF  07
00C5:  BCF    03.5
00C6:  BSF    07.4
.................... else 
00C7:  GOTO   0CE
....................    output_low(LCD_RS); 
00C8:  BCF    20.4
00C9:  MOVF   20,W
00CA:  BSF    03.5
00CB:  MOVWF  07
00CC:  BCF    03.5
00CD:  BCF    07.4
....................  
....................  delay_cycles(1); 
00CE:  NOP
....................  
.................... #ifdef USE_LCD_RW 
.................... //output_low(LCD_RW); 
.................... delay_cycles(1); 
00CF:  NOP
.................... #endif 
....................  
.................... output_low(LCD_E); 
00D0:  BCF    20.5
00D1:  MOVF   20,W
00D2:  BSF    03.5
00D3:  MOVWF  07
00D4:  BCF    03.5
00D5:  BCF    07.5
....................  
.................... lcd_send_nibble(n >> 4); 
00D6:  SWAPF  28,W
00D7:  MOVWF  29
00D8:  MOVLW  0F
00D9:  ANDWF  29,F
00DA:  MOVF   29,W
00DB:  MOVWF  2A
00DC:  CALL   032
.................... lcd_send_nibble(n & 0xf); 
00DD:  MOVF   28,W
00DE:  ANDLW  0F
00DF:  MOVWF  29
00E0:  MOVWF  2A
00E1:  CALL   032
.................... } 
00E2:  RETLW  00
....................  
.................... //---------------------------- 
.................... void lcd_init(void) 
.................... { 
.................... int8 i; 
....................  
.................... output_low(LCD_RS); 
00E3:  BCF    20.4
00E4:  MOVF   20,W
00E5:  BSF    03.5
00E6:  MOVWF  07
00E7:  BCF    03.5
00E8:  BCF    07.4
....................  
.................... #ifdef USE_LCD_RW 
.................... //output_low(LCD_RW); 
.................... #endif 
....................  
.................... output_low(LCD_E); 
00E9:  BCF    20.5
00EA:  MOVF   20,W
00EB:  BSF    03.5
00EC:  MOVWF  07
00ED:  BCF    03.5
00EE:  BCF    07.5
....................  
.................... delay_ms(15); 
00EF:  MOVLW  0F
00F0:  MOVWF  23
00F1:  CALL   01F
....................  
.................... for(i=0 ;i < 3; i++) 
00F2:  CLRF   21
00F3:  MOVF   21,W
00F4:  SUBLW  02
00F5:  BTFSS  03.0
00F6:  GOTO   0FF
....................    { 
....................     lcd_send_nibble(0x03); 
00F7:  MOVLW  03
00F8:  MOVWF  2A
00F9:  CALL   032
....................     delay_ms(5); 
00FA:  MOVLW  05
00FB:  MOVWF  23
00FC:  CALL   01F
....................    } 
00FD:  INCF   21,F
00FE:  GOTO   0F3
....................  
.................... lcd_send_nibble(0x02); 
00FF:  MOVLW  02
0100:  MOVWF  2A
0101:  CALL   032
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++) 
0102:  CLRF   21
0103:  MOVF   21,W
0104:  SUBLW  03
0105:  BTFSS  03.0
0106:  GOTO   110
....................    { 
....................     lcd_send_byte(0, LCD_INIT_STRING[i]); 
0107:  MOVF   21,W
0108:  CALL   004
0109:  MOVWF  22
010A:  CLRF   27
010B:  MOVF   22,W
010C:  MOVWF  28
010D:  CALL   0A6
....................  
....................     // If the R/W signal is not used, then 
....................     // the busy bit can't be polled.  One of 
....................     // the init commands takes longer than 
....................     // the hard-coded delay of 60 us, so in 
....................     // that case, lets just do a 5 ms delay 
....................     // after all four of them. 
....................     #ifndef USE_LCD_RW 
....................     delay_ms(5); 
....................     #endif 
....................    } 
010E:  INCF   21,F
010F:  GOTO   103
....................  
.................... } 
0110:  BCF    0A.3
0111:  BCF    0A.4
0112:  GOTO   15C (RETURN)
....................  
.................... //---------------------------- 
....................  
.................... void lcd_gotoxy(int8 x, int8 y) 
.................... { 
.................... int8 address; 
....................  
.................... if(y != 1) 
*
012A:  DECFSZ 24,W
012B:  GOTO   12D
012C:  GOTO   130
....................    address = lcd_line_two; 
012D:  MOVLW  80
012E:  MOVWF  25
.................... else 
012F:  GOTO   131
....................    address=0; 
0130:  CLRF   25
....................  
.................... address += x-1; 
0131:  MOVLW  01
0132:  SUBWF  23,W
0133:  ADDWF  25,F
.................... lcd_send_byte(0, 0x80 | address); 
0134:  MOVF   25,W
0135:  IORLW  80
0136:  MOVWF  26
0137:  CLRF   27
0138:  MOVF   26,W
0139:  MOVWF  28
013A:  CALL   0A6
.................... } 
....................  
.................... //----------------------------- 
.................... void lcd_putc(char c) 
.................... { 
....................  switch(c) 
....................    { 
*
0113:  MOVF   22,W
0114:  XORLW  0C
0115:  BTFSC  03.2
0116:  GOTO   11E
0117:  XORLW  06
0118:  BTFSC  03.2
0119:  GOTO   126
011A:  XORLW  02
011B:  BTFSC  03.2
011C:  GOTO   13C
011D:  GOTO   141
....................     case '\f': 
....................       lcd_send_byte(0,1); 
011E:  CLRF   27
011F:  MOVLW  01
0120:  MOVWF  28
0121:  CALL   0A6
....................       delay_ms(2); 
0122:  MOVLW  02
0123:  MOVWF  23
0124:  CALL   01F
....................       break; 
0125:  GOTO   147
....................  
....................     case '\n': 
....................        lcd_gotoxy(1,2); 
0126:  MOVLW  01
0127:  MOVWF  23
0128:  MOVLW  02
0129:  MOVWF  24
....................        break; 
*
013B:  GOTO   147
....................  
....................     case '\b': 
....................        lcd_send_byte(0,0x10); 
013C:  CLRF   27
013D:  MOVLW  10
013E:  MOVWF  28
013F:  CALL   0A6
....................        break; 
0140:  GOTO   147
....................  
....................     default: 
....................        lcd_send_byte(1,c); 
0141:  MOVLW  01
0142:  MOVWF  27
0143:  MOVF   22,W
0144:  MOVWF  28
0145:  CALL   0A6
....................        break; 
0146:  GOTO   147
....................    } 
.................... } 
0147:  BCF    0A.3
0148:  BCF    0A.4
0149:  GOTO   168 (RETURN)
....................  
.................... //------------------------------ 
.................... #ifdef USE_LCD_RW 
.................... char lcd_getc(int8 x, int8 y) 
.................... { 
.................... char value; 
....................  
.................... lcd_gotoxy(x,y); 
....................  
.................... // Wait until busy flag is low. 
.................... while(bit_test(lcd_read_byte(),7));  
....................  
.................... output_high(LCD_RS); 
.................... value = lcd_read_byte(); 
.................... output_low(lcd_RS); 
....................  
.................... return(value); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////// 
.................... //////////////////////////////////////////////// 
.................... ///////          MAIN PROGRAM          ///////// 
.................... //////////////////////////////////////////////// 
.................... //////////////////////////////////////////////// 
....................  
....................  
.................... VOID MAIN() 
.................... { 
014A:  CLRF   04
014B:  MOVLW  1F
014C:  ANDWF  03,F
014D:  BSF    03.5
014E:  BSF    1F.0
014F:  BSF    1F.1
0150:  BSF    1F.2
0151:  BCF    1F.3
0152:  MOVLW  07
0153:  MOVWF  1C
....................          //76543210// RESPECTIVE PINS IN THE PORT// 0B REFERS TO BINARY// 0X REFERS TO HEX 
....................    TRISC=0B00000000;                      ///  HERE ALL PINS ARE MADE TO OPERATE AS  O/P 
*
0157:  BSF    03.5
0158:  CLRF   07
....................    PORTC=0B00000000;                      // INITILAL STATUS OF PIN IS MADE TO BE 0 
0159:  BCF    03.5
015A:  CLRF   07
....................     
....................     
....................    lcd_init(); 
015B:  GOTO   0E3
....................    DELAY_MS(100); 
015C:  MOVLW  64
015D:  MOVWF  23
015E:  CALL   01F
....................    LCD_PUTC("GRT WELCOMES U"); 
015F:  CLRF   21
0160:  MOVF   21,W
0161:  CALL   00C
0162:  IORLW  00
0163:  BTFSC  03.2
0164:  GOTO   169
0165:  INCF   21,F
0166:  MOVWF  22
0167:  GOTO   113
0168:  GOTO   160
....................    WHILE(1) 
....................    { 
....................  
....................    } 
0169:  GOTO   169
....................     
....................     
.................... } 
016A:  SLEEP
