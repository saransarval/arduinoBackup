CCS PCM C Compiler, Version 3.249, 33340               10-Mar-14 02:40

               Filename: E:\Ganesh Potti\Ganesh Projects\Engineers Projects\GLCD\GLCD_pro.lst

               ROM used: 3110 words (38%)
                         Largest free fragment is 2048
               RAM used: 79 (45%) at main() level
                         113 (65%) worst case
               Stack:    3 locations

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   35B
0003:  NOP
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #use delay(clock=11059200) 
*
0732:  MOVLW  6A
0733:  MOVWF  04
0734:  MOVF   00,W
0735:  BTFSC  03.2
0736:  GOTO   744
0737:  MOVLW  03
0738:  MOVWF  78
0739:  CLRF   77
073A:  DECFSZ 77,F
073B:  GOTO   73A
073C:  DECFSZ 78,F
073D:  GOTO   739
073E:  MOVLW  95
073F:  MOVWF  77
0740:  DECFSZ 77,F
0741:  GOTO   740
0742:  DECFSZ 00,F
0743:  GOTO   737
0744:  RETLW  00
.................... #include "Header_GLCD.h" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           GLCD.C                                //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// an LED backlight. The HDM64GS12 is 128 pixles across and 64     //// 
.................... //// pixels down. The driver treats the upper left pixel as (0,0).   //// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0 - LCD operating voltage is connected from a 20k Ohm POT//// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1,y1,x2,y2,color)                                   //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color.                                     //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1,y1,x2,y2,fill,color)                              //// 
.................... ////     * Draws a rectangle with upper left point (x1,y1) and lower //// 
.................... ////       right point (x2,y2).                                      //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1,y1,x2,y2,width,color)                              //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point.                                             //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x,y,radius,fill,color)                             //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x,y,textptr,size,color)                            //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y).//// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall.           //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - The given text is character wrapped. If this       //// 
.................... ////       function is used on a different size display, then change //// 
.................... ////       the GLCD_WIDTH define appropriately.                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef GLCD_C 
.................... #define GLCD_C 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH 128    // Used for text wrapping by glcd_text57 function 
.................... #endif 
....................  
.................... #define ON  1 
.................... #define OFF 0 
....................  
.................... #define YES 1 
.................... #define NO  0 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1 PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2 PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI  PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW  PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E   PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST PIN_C0   // Reset 
.................... #endif 
....................  
....................  
....................  
.................... BYTE glcd_readByte(BYTE chip); 
.................... void glcd_writeByte(BYTE chip, BYTE data); 
.................... void glcd_fillScreen(int1 color); 
....................  
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
....................  
.................... // Purpose:       Initialize a graphic LCD. This must be called before any 
.................... //                other glcd function is used. 
.................... // Inputs:        The initialization mode 
.................... //                OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... // Date:          5/28/2003 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
06CE:  BCF    20.0
06CF:  MOVF   20,W
06D0:  BSF    03.5
06D1:  MOVWF  07
06D2:  BCF    03.5
06D3:  BSF    07.0
*
0B65:  MOVLW  FF
0B66:  BCF    03.5
0B67:  MOVWF  20
....................    output_low(GLCD_E); 
*
06D4:  BSF    03.5
06D5:  BCF    06.5
06D6:  BCF    03.5
06D7:  BCF    06.5
....................    output_low(GLCD_CS1); 
06D8:  BSF    03.5
06D9:  BCF    06.0
06DA:  BCF    03.5
06DB:  BCF    06.0
....................    output_low(GLCD_CS2); 
06DC:  BSF    03.5
06DD:  BCF    06.1
06DE:  BCF    03.5
06DF:  BCF    06.1
....................  
....................    output_low(GLCD_DI);                // Set for instruction 
06E0:  BSF    03.5
06E1:  BCF    06.2
06E2:  BCF    03.5
06E3:  BCF    06.2
....................    glcd_writeByte(GLCD_CS1, 0xC0);     // Specify first RAM line at the top 
06E4:  MOVLW  30
06E5:  BSF    03.5
06E6:  MOVWF  30
06E7:  MOVLW  C0
06E8:  MOVWF  31
06E9:  BCF    03.5
06EA:  CALL   616
....................    glcd_writeByte(GLCD_CS2, 0xC0);     //   of the screen 
06EB:  MOVLW  31
06EC:  BSF    03.5
06ED:  MOVWF  30
06EE:  MOVLW  C0
06EF:  MOVWF  31
06F0:  BCF    03.5
06F1:  CALL   616
....................    glcd_writeByte(GLCD_CS1, 0x40);     // Set the column address to 0 
06F2:  MOVLW  30
06F3:  BSF    03.5
06F4:  MOVWF  30
06F5:  MOVLW  40
06F6:  MOVWF  31
06F7:  BCF    03.5
06F8:  CALL   616
....................    glcd_writeByte(GLCD_CS2, 0x40); 
06F9:  MOVLW  31
06FA:  BSF    03.5
06FB:  MOVWF  30
06FC:  MOVLW  40
06FD:  MOVWF  31
06FE:  BCF    03.5
06FF:  CALL   616
....................    glcd_writeByte(GLCD_CS1, 0xB8);     // Set the page address to 0 
0700:  MOVLW  30
0701:  BSF    03.5
0702:  MOVWF  30
0703:  MOVLW  B8
0704:  MOVWF  31
0705:  BCF    03.5
0706:  CALL   616
....................    glcd_writeByte(GLCD_CS2, 0xB8); 
0707:  MOVLW  31
0708:  BSF    03.5
0709:  MOVWF  30
070A:  MOVLW  B8
070B:  MOVWF  31
070C:  BCF    03.5
070D:  CALL   616
....................    if(mode == ON) 
070E:  DECFSZ 69,W
070F:  GOTO   71F
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3F);  // Turn the display on 
0710:  MOVLW  30
0711:  BSF    03.5
0712:  MOVWF  30
0713:  MOVLW  3F
0714:  MOVWF  31
0715:  BCF    03.5
0716:  CALL   616
....................       glcd_writeByte(GLCD_CS2, 0x3F); 
0717:  MOVLW  31
0718:  BSF    03.5
0719:  MOVWF  30
071A:  MOVLW  3F
071B:  MOVWF  31
071C:  BCF    03.5
071D:  CALL   616
....................    } 
....................    else 
071E:  GOTO   72D
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3E);  // Turn the display off 
071F:  MOVLW  30
0720:  BSF    03.5
0721:  MOVWF  30
0722:  MOVLW  3E
0723:  MOVWF  31
0724:  BCF    03.5
0725:  CALL   616
....................       glcd_writeByte(GLCD_CS2, 0x3E); 
0726:  MOVLW  31
0727:  BSF    03.5
0728:  MOVWF  30
0729:  MOVLW  3E
072A:  MOVWF  31
072B:  BCF    03.5
072C:  CALL   616
....................    } 
....................  
....................    glcd_fillScreen(OFF);               // Clear the display 
072D:  CLRF   6A
072E:  CALL   669
.................... } 
072F:  BSF    0A.3
0730:  BCF    0A.4
0731:  GOTO   3E8 (RETURN)
....................  
....................  
.................... // Purpose:       Turn a pixel on a graphic LCD on or off 
.................... // Inputs:        x - the x coordinate of the pixel 
.................... //                y - the y coordinate of the pixel 
.................... //                color - ON or OFF 
.................... // Output:        1 if coordinate out of range, 0 if in range 
.................... void glcd_pixel(int x, int y, int1 color) 
.................... { 
....................    BYTE data; 
....................    BYTE chip = GLCD_CS1;  // Stores which chip to use on the LCD 
*
0A59:  MOVLW  30
0A5A:  MOVWF  2C
....................  
....................    if(x > 63)  // Check for first or second display area 
0A5B:  MOVF   28,W
0A5C:  SUBLW  3F
0A5D:  BTFSC  03.0
0A5E:  GOTO   263
....................    { 
....................       x -= 64; 
0A5F:  MOVLW  40
0A60:  SUBWF  28,F
....................       chip = GLCD_CS2; 
0A61:  MOVLW  31
0A62:  MOVWF  2C
....................    } 
....................  
....................    output_low(GLCD_DI);                                     // Set for instruction 
0A63:  BCF    06.2
0A64:  BCF    03.5
0A65:  BCF    06.2
....................    bit_clear(x,7);                                          // Clear the MSB. Part of an instruction code 
0A66:  BSF    03.5
0A67:  BCF    28.7
....................    bit_set(x,6);                                            // Set bit 6. Also part of an instruction code 
0A68:  BSF    28.6
....................    glcd_writeByte(chip, x);                                 // Set the horizontal address 
0A69:  MOVF   2C,W
0A6A:  MOVWF  30
0A6B:  MOVF   28,W
0A6C:  MOVWF  31
0A6D:  BCF    0A.3
0A6E:  BCF    03.5
0A6F:  CALL   616
0A70:  BSF    0A.3
....................    glcd_writeByte(chip, (y/8 & 0b10111111) | 0b10111000);   // Set the vertical page address 
0A71:  BSF    03.5
0A72:  RRF    29,W
0A73:  MOVWF  77
0A74:  RRF    77,F
0A75:  RRF    77,F
0A76:  MOVLW  1F
0A77:  ANDWF  77,F
0A78:  MOVF   77,W
0A79:  ANDLW  BF
0A7A:  IORLW  B8
0A7B:  MOVWF  2F
0A7C:  MOVF   2C,W
0A7D:  MOVWF  30
0A7E:  MOVF   2F,W
0A7F:  MOVWF  31
0A80:  BCF    0A.3
0A81:  BCF    03.5
0A82:  CALL   616
0A83:  BSF    0A.3
....................    output_high(GLCD_DI);                                    // Set for data 
0A84:  BSF    03.5
0A85:  BCF    06.2
0A86:  BCF    03.5
0A87:  BSF    06.2
....................    data = glcd_readByte(chip); 
0A88:  BSF    03.5
0A89:  MOVF   2C,W
0A8A:  MOVWF  2D
*
0ACC:  MOVF   78,W
0ACD:  MOVWF  2B
....................  
....................    if(color == ON) 
0ACE:  DECFSZ 2A,W
0ACF:  GOTO   2E0
....................       bit_set(data, y%8);        // Turn the pixel on 
0AD0:  MOVF   29,W
0AD1:  ANDLW  07
0AD2:  MOVWF  2D
0AD3:  MOVLW  01
0AD4:  MOVWF  77
0AD5:  MOVF   2D,W
0AD6:  MOVWF  78
0AD7:  BTFSC  03.2
0AD8:  GOTO   2DD
0AD9:  BCF    03.0
0ADA:  RLF    77,F
0ADB:  DECFSZ 78,F
0ADC:  GOTO   2D9
0ADD:  MOVF   77,W
0ADE:  IORWF  2B,F
....................    else                          // or 
0ADF:  GOTO   2F0
....................       bit_clear(data, y%8);      // turn the pixel off 
0AE0:  MOVF   29,W
0AE1:  ANDLW  07
0AE2:  MOVWF  2D
0AE3:  MOVLW  01
0AE4:  MOVWF  77
0AE5:  MOVF   2D,W
0AE6:  MOVWF  78
0AE7:  BTFSC  03.2
0AE8:  GOTO   2ED
0AE9:  BCF    03.0
0AEA:  RLF    77,F
0AEB:  DECFSZ 78,F
0AEC:  GOTO   2E9
0AED:  MOVF   77,W
0AEE:  XORLW  FF
0AEF:  ANDWF  2B,F
....................    output_low(GLCD_DI);          // Set for instruction 
0AF0:  BCF    06.2
0AF1:  BCF    03.5
0AF2:  BCF    06.2
....................    glcd_writeByte(chip, x);      // Set the horizontal address 
0AF3:  BSF    03.5
0AF4:  MOVF   2C,W
0AF5:  MOVWF  30
0AF6:  MOVF   28,W
0AF7:  MOVWF  31
0AF8:  BCF    0A.3
0AF9:  BCF    03.5
0AFA:  CALL   616
0AFB:  BSF    0A.3
....................    output_high(GLCD_DI);         // Set for data 
0AFC:  BSF    03.5
0AFD:  BCF    06.2
0AFE:  BCF    03.5
0AFF:  BSF    06.2
....................    glcd_writeByte(chip, data);   // Write the pixel data 
0B00:  BSF    03.5
0B01:  MOVF   2C,W
0B02:  MOVWF  30
0B03:  MOVF   2B,W
0B04:  MOVWF  31
0B05:  BCF    0A.3
0B06:  BCF    03.5
0B07:  CALL   616
0B08:  BSF    0A.3
.................... } 
....................  
....................  
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................  
....................    if(x1 > x2) 
....................       addx = -1; 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................       addy = -1; 
....................    else 
....................       addy = 1; 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          glcd_pixel(x, y, color); 
....................  
....................          if(P < 0) 
....................          { 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          glcd_pixel(x, y, color); 
....................  
....................          if(P < 0) 
....................          { 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... void glcd_rect(int x1, int y1, int x2, int y2, int fill, int1 color) 
.................... { 
....................    if(fill) 
....................    { 
....................       int y, ymax;                          // Find the y min and max 
....................       if(y1 < y2) 
....................       { 
....................          y = y1; 
....................          ymax = y2; 
....................       } 
....................       else 
....................       { 
....................          y = y2; 
....................          ymax = y1; 
....................       } 
....................  
....................       for(; y<=ymax; ++y)                    // Draw lines to fill the rectangle 
....................          glcd_line(x1, y, x2, y, color); 
....................    } 
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
....................       glcd_line(x1, y2, x2, y2, color); 
....................       glcd_line(x1, y1, x1, y2, color); 
....................       glcd_line(x2, y1, x2, y2, color); 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... void glcd_bar(int x1, int y1, int x2, int y2, int width, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, j; 
....................    signed long P, dx, dy, c1, c2; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................    c1 = -dx*x1 - dy*y1; 
....................    c2 = -dx*x2 - dy*y2; 
....................  
....................    if(x1 > x2) 
....................    { 
....................       addx = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................    { 
....................       addy = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addy = 1; 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x, y+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x+j, y, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... void glcd_circle(int x, int y, int radius, int1 fill, int1 color) 
.................... { 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... void glcd_text57(int x, int y, char* textptr, int size, int1 color) 
.................... { 
....................    int i, j, k, l, m;                     // Loop counters 
....................    BYTE pixelData[5];                     // Stores character data 
....................  
....................    for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string 
*
098A:  CLRF   6E
098B:  MOVF   6B,W
098C:  ADDWF  6E,W
098D:  MOVWF  04
098E:  MOVF   00,F
098F:  BTFSC  03.2
0990:  GOTO   318
....................    { 
....................       if(textptr[i] < 'S') // Checks if the letter is in the first text array 
0991:  MOVF   6B,W
0992:  ADDWF  6E,W
0993:  MOVWF  04
0994:  MOVF   00,W
0995:  SUBLW  52
0996:  BTFSS  03.0
0997:  GOTO   1BC
....................          memcpy(pixelData, TEXT[textptr[i]-' '], 5); 
0998:  MOVF   6B,W
0999:  ADDWF  6E,W
099A:  MOVWF  04
099B:  MOVLW  20
099C:  SUBWF  00,W
099D:  BSF    03.5
099E:  MOVWF  27
099F:  MOVWF  28
09A0:  MOVLW  05
09A1:  MOVWF  29
09A2:  BCF    0A.3
09A3:  BCF    03.5
09A4:  CALL   642
09A5:  BSF    0A.3
09A6:  MOVF   78,W
09A7:  BSF    03.5
09A8:  MOVWF  28
09A9:  MOVWF  79
09AA:  MOVLW  05
09AB:  MOVWF  78
09AC:  MOVLW  A0
09AD:  MOVWF  04
09AE:  MOVF   79,W
09AF:  BCF    0A.3
09B0:  BCF    03.5
09B1:  CALL   004
09B2:  BSF    0A.3
09B3:  MOVWF  00
09B4:  INCF   79,F
09B5:  INCF   04,F
09B6:  DECFSZ 78,F
09B7:  GOTO   1B9
09B8:  GOTO   1BB
09B9:  BSF    03.5
09BA:  GOTO   1AE
....................       else if(textptr[i] <= '~') // Check if the letter is in the second array 
09BB:  GOTO   1EE
09BC:  MOVF   6B,W
09BD:  ADDWF  6E,W
09BE:  MOVWF  04
09BF:  MOVF   00,W
09C0:  SUBLW  7E
09C1:  BTFSS  03.0
09C2:  GOTO   1E7
....................          memcpy(pixelData, TEXT2[textptr[i]-'S'], 5); 
09C3:  MOVF   6B,W
09C4:  ADDWF  6E,W
09C5:  MOVWF  04
09C6:  MOVLW  53
09C7:  SUBWF  00,W
09C8:  BSF    03.5
09C9:  MOVWF  27
09CA:  MOVWF  28
09CB:  MOVLW  05
09CC:  MOVWF  29
09CD:  BCF    0A.3
09CE:  BCF    03.5
09CF:  CALL   642
09D0:  BSF    0A.3
09D1:  MOVF   78,W
09D2:  BSF    03.5
09D3:  MOVWF  28
09D4:  MOVWF  79
09D5:  MOVLW  05
09D6:  MOVWF  78
09D7:  MOVLW  A0
09D8:  MOVWF  04
09D9:  MOVF   79,W
09DA:  BCF    0A.3
09DB:  BCF    03.5
09DC:  CALL   10A
09DD:  BSF    0A.3
09DE:  MOVWF  00
09DF:  INCF   79,F
09E0:  INCF   04,F
09E1:  DECFSZ 78,F
09E2:  GOTO   1E4
09E3:  GOTO   1E6
09E4:  BSF    03.5
09E5:  GOTO   1D9
....................       else 
09E6:  GOTO   1EE
....................          memcpy(pixelData, TEXT[0], 5);   // Default to space 
09E7:  BSF    03.5
09E8:  CLRF   20
09E9:  CLRF   21
09EA:  CLRF   22
09EB:  CLRF   23
09EC:  CLRF   24
09ED:  BCF    03.5
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
09EE:  MOVLW  05
09EF:  BSF    03.5
09F0:  MOVWF  28
09F1:  BCF    03.5
09F2:  MOVF   6C,W
09F3:  BSF    03.5
09F4:  MOVWF  29
09F5:  BCF    0A.3
09F6:  BCF    03.5
09F7:  CALL   642
09F8:  BSF    0A.3
09F9:  MOVF   78,W
09FA:  ADDWF  69,W
09FB:  SUBLW  7F
09FC:  BTFSC  03.0
09FD:  GOTO   20D
....................       { 
....................          x = 0;                           // Set x at far left position 
09FE:  CLRF   69
....................          y += 7*size + 1;                 // Set y at next position down 
09FF:  MOVLW  07
0A00:  BSF    03.5
0A01:  MOVWF  28
0A02:  BCF    03.5
0A03:  MOVF   6C,W
0A04:  BSF    03.5
0A05:  MOVWF  29
0A06:  BCF    0A.3
0A07:  BCF    03.5
0A08:  CALL   642
0A09:  BSF    0A.3
0A0A:  MOVLW  01
0A0B:  ADDWF  78,W
0A0C:  ADDWF  6A,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
0A0D:  CLRF   6F
0A0E:  MOVF   6F,W
0A0F:  SUBLW  04
0A10:  BTFSS  03.0
0A11:  GOTO   315
....................       { 
....................          for(k=0; k<7*size; ++k)          // Loop through the vertical pixels 
0A12:  CLRF   70
0A13:  MOVLW  07
0A14:  BSF    03.5
0A15:  MOVWF  28
0A16:  BCF    03.5
0A17:  MOVF   6C,W
0A18:  BSF    03.5
0A19:  MOVWF  29
0A1A:  BCF    0A.3
0A1B:  BCF    03.5
0A1C:  CALL   642
0A1D:  BSF    0A.3
0A1E:  MOVF   78,W
0A1F:  SUBWF  70,W
0A20:  BTFSC  03.0
0A21:  GOTO   311
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
0A22:  MOVLW  A0
0A23:  ADDWF  6F,W
0A24:  MOVWF  04
0A25:  MOVF   00,W
0A26:  BSF    03.5
0A27:  MOVWF  25
0A28:  MOVWF  77
0A29:  MOVF   70,W
0A2A:  MOVWF  78
0A2B:  BTFSC  03.2
0A2C:  GOTO   231
0A2D:  BCF    03.0
0A2E:  RRF    77,F
0A2F:  DECFSZ 78,F
0A30:  GOTO   22D
0A31:  BTFSS  77.0
0A32:  GOTO   30E
....................             { 
....................                for(l=0; l<size; ++l)      // The next two loops change the 
0A33:  CLRF   71
0A34:  BCF    03.5
0A35:  MOVF   6C,W
0A36:  SUBWF  71,W
0A37:  BTFSC  03.0
0A38:  GOTO   30F
....................                {                          // character's size 
....................                   for(m=0; m<size; ++m) 
0A39:  CLRF   72
0A3A:  MOVF   6C,W
0A3B:  SUBWF  72,W
0A3C:  BTFSC  03.0
0A3D:  GOTO   30B
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
0A3E:  MOVF   72,W
0A3F:  ADDWF  69,W
0A40:  BSF    03.5
0A41:  MOVWF  25
0A42:  MOVF   70,W
0A43:  MOVWF  28
0A44:  BCF    03.5
0A45:  MOVF   6C,W
0A46:  BSF    03.5
0A47:  MOVWF  29
0A48:  BCF    0A.3
0A49:  BCF    03.5
0A4A:  CALL   642
0A4B:  BSF    0A.3
0A4C:  MOVF   78,W
0A4D:  ADDWF  6A,W
0A4E:  ADDWF  71,W
0A4F:  BSF    03.5
0A50:  MOVWF  27
0A51:  MOVF   25,W
0A52:  MOVWF  28
0A53:  MOVF   27,W
0A54:  MOVWF  29
0A55:  BCF    03.5
0A56:  MOVF   6D,W
0A57:  BSF    03.5
0A58:  MOVWF  2A
....................                   } 
*
0B09:  INCF   72,F
0B0A:  GOTO   23A
....................                } 
0B0B:  INCF   71,F
0B0C:  BSF    03.5
0B0D:  GOTO   234
0B0E:  BCF    03.5
....................             } 
....................          } 
0B0F:  INCF   70,F
0B10:  GOTO   213
....................       } 
0B11:  INCF   6F,F
0B12:  MOVF   6C,W
0B13:  ADDWF  69,F
0B14:  GOTO   20E
....................    } 
0B15:  INCF   6E,F
0B16:  INCF   69,F
0B17:  GOTO   18B
.................... } 
0B18:  RETLW  00
....................  
....................  
.................... // Purpose:       Fill the LCD screen with the passed in color. 
.................... //                Works much faster than drawing a rectangle to fill the screen. 
.................... // Inputs:        ON - turn all the pixels on 
.................... //                OFF - turn all the pixels off 
.................... // Dependencies:  glcd_writeByte() 
.................... void glcd_fillScreen(int1 color) 
.................... { 
....................    int i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
0669:  CLRF   6B
066A:  MOVF   6B,W
066B:  SUBLW  07
066C:  BTFSS  03.0
066D:  GOTO   6CD
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
066E:  BSF    03.5
066F:  BCF    06.2
0670:  BCF    03.5
0671:  BCF    06.2
....................       glcd_writeByte(GLCD_CS1, 0b01000000);     // Set horizontal address to 0 
0672:  MOVLW  30
0673:  BSF    03.5
0674:  MOVWF  30
0675:  MOVLW  40
0676:  MOVWF  31
0677:  BCF    03.5
0678:  CALL   616
....................       glcd_writeByte(GLCD_CS2, 0b01000000); 
0679:  MOVLW  31
067A:  BSF    03.5
067B:  MOVWF  30
067C:  MOVLW  40
067D:  MOVWF  31
067E:  BCF    03.5
067F:  CALL   616
....................       glcd_writeByte(GLCD_CS1, i | 0b10111000); // Set page address 
0680:  MOVF   6B,W
0681:  IORLW  B8
0682:  MOVWF  6D
0683:  MOVLW  30
0684:  BSF    03.5
0685:  MOVWF  30
0686:  BCF    03.5
0687:  MOVF   6D,W
0688:  BSF    03.5
0689:  MOVWF  31
068A:  BCF    03.5
068B:  CALL   616
....................       glcd_writeByte(GLCD_CS2, i | 0b10111000); 
068C:  MOVF   6B,W
068D:  IORLW  B8
068E:  MOVWF  6D
068F:  MOVLW  31
0690:  BSF    03.5
0691:  MOVWF  30
0692:  BCF    03.5
0693:  MOVF   6D,W
0694:  BSF    03.5
0695:  MOVWF  31
0696:  BCF    03.5
0697:  CALL   616
....................       output_high(GLCD_DI);                     // Set for data 
0698:  BSF    03.5
0699:  BCF    06.2
069A:  BCF    03.5
069B:  BSF    06.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
069C:  CLRF   6C
069D:  MOVF   6C,W
069E:  SUBLW  3F
069F:  BTFSS  03.0
06A0:  GOTO   6CB
....................       { 
....................          glcd_writeByte(GLCD_CS1, 0xFF*color);  // Turn pixels on or off 
06A1:  MOVLW  FF
06A2:  BSF    03.5
06A3:  MOVWF  28
06A4:  BCF    03.5
06A5:  MOVF   6A,W
06A6:  BSF    03.5
06A7:  MOVWF  29
06A8:  BCF    03.5
06A9:  CALL   642
06AA:  MOVF   78,W
06AB:  MOVWF  6D
06AC:  MOVLW  30
06AD:  BSF    03.5
06AE:  MOVWF  30
06AF:  BCF    03.5
06B0:  MOVF   78,W
06B1:  BSF    03.5
06B2:  MOVWF  31
06B3:  BCF    03.5
06B4:  CALL   616
....................          glcd_writeByte(GLCD_CS2, 0xFF*color);  // Turn pixels on or off 
06B5:  MOVLW  FF
06B6:  BSF    03.5
06B7:  MOVWF  28
06B8:  BCF    03.5
06B9:  MOVF   6A,W
06BA:  BSF    03.5
06BB:  MOVWF  29
06BC:  BCF    03.5
06BD:  CALL   642
06BE:  MOVF   78,W
06BF:  MOVWF  6D
06C0:  MOVLW  31
06C1:  BSF    03.5
06C2:  MOVWF  30
06C3:  BCF    03.5
06C4:  MOVF   78,W
06C5:  BSF    03.5
06C6:  MOVWF  31
06C7:  BCF    03.5
06C8:  CALL   616
....................       } 
06C9:  INCF   6C,F
06CA:  GOTO   69D
....................    } 
06CB:  INCF   6B,F
06CC:  GOTO   66A
.................... } 
06CD:  RETLW  00
....................  
.................... // Purpose:       Write a byte of data to the specified chip 
.................... // Inputs:        chipSelect - which chip to write the data to 
.................... //                data - the byte of data to write 
....................  
.................... void glcd_writeByte(char chip, BYTE data) 
.................... { 
....................    if(chip == GLCD_CS1)       // Choose which chip to write to 
*
0616:  BSF    03.5
0617:  MOVF   30,W
0618:  SUBLW  30
0619:  BTFSS  03.2
061A:  GOTO   620
....................       output_high(GLCD_CS1); 
061B:  BCF    06.0
061C:  BCF    03.5
061D:  BSF    06.0
....................    else 
061E:  GOTO   623
061F:  BSF    03.5
....................       output_high(GLCD_CS2); 
0620:  BCF    06.1
0621:  BCF    03.5
0622:  BSF    06.1
....................  
....................    output_low(GLCD_RW);       // Set for writing 
0623:  BSF    03.5
0624:  BCF    06.4
0625:  BCF    03.5
0626:  BCF    06.4
....................    output_d(data);            // Put the data on the port 
0627:  BSF    03.5
0628:  CLRF   08
0629:  MOVF   31,W
062A:  BCF    03.5
062B:  MOVWF  08
....................    output_high(GLCD_E);       // Pulse the enable pin 
062C:  BSF    03.5
062D:  BCF    06.5
062E:  BCF    03.5
062F:  BSF    06.5
....................    delay_us(2); 
0630:  NOP
0631:  NOP
0632:  NOP
0633:  NOP
0634:  NOP
....................    output_low(GLCD_E); 
0635:  BSF    03.5
0636:  BCF    06.5
0637:  BCF    03.5
0638:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
0639:  BSF    03.5
063A:  BCF    06.0
063B:  BCF    03.5
063C:  BCF    06.0
....................    output_low(GLCD_CS2); 
063D:  BSF    03.5
063E:  BCF    06.1
063F:  BCF    03.5
0640:  BCF    06.1
.................... } 
0641:  RETLW  00
....................  
....................  
.................... // Purpose:       Reads a byte of data from the specified chip 
.................... // Ouputs:        A byte of data read from the chip 
.................... BYTE glcd_readByte(BYTE chip) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................    if(chip == GLCD_CS1)       // Choose which chip to read from 
*
0A8B:  MOVF   2D,W
0A8C:  SUBLW  30
0A8D:  BTFSS  03.2
0A8E:  GOTO   294
....................       output_high(GLCD_CS1); 
0A8F:  BCF    06.0
0A90:  BCF    03.5
0A91:  BSF    06.0
....................    else 
0A92:  GOTO   297
0A93:  BSF    03.5
....................       output_high(GLCD_CS2); 
0A94:  BCF    06.1
0A95:  BCF    03.5
0A96:  BSF    06.1
....................  
....................    input_d();                 // Set port d to input 
0A97:  MOVLW  FF
0A98:  BSF    03.5
0A99:  MOVWF  08
....................    output_high(GLCD_RW);      // Set for reading 
0A9A:  BCF    06.4
0A9B:  BCF    03.5
0A9C:  BSF    06.4
....................    output_high(GLCD_E);       // Pulse the enable pin 
0A9D:  BSF    03.5
0A9E:  BCF    06.5
0A9F:  BCF    03.5
0AA0:  BSF    06.5
....................    delay_us(2); 
0AA1:  NOP
0AA2:  NOP
0AA3:  NOP
0AA4:  NOP
0AA5:  NOP
....................    output_low(GLCD_E); 
0AA6:  BSF    03.5
0AA7:  BCF    06.5
0AA8:  BCF    03.5
0AA9:  BCF    06.5
....................    delay_us(2); 
0AAA:  NOP
0AAB:  NOP
0AAC:  NOP
0AAD:  NOP
0AAE:  NOP
....................    output_high(GLCD_E);       // Pulse the enable pin 
0AAF:  BSF    03.5
0AB0:  BCF    06.5
0AB1:  BCF    03.5
0AB2:  BSF    06.5
....................    delay_us(2); 
0AB3:  NOP
0AB4:  NOP
0AB5:  NOP
0AB6:  NOP
0AB7:  NOP
....................    data = input_d();          // Get the data from the display's output register 
0AB8:  BSF    03.5
0AB9:  MOVWF  08
0ABA:  BCF    03.5
0ABB:  MOVF   08,W
0ABC:  BSF    03.5
0ABD:  MOVWF  2E
....................    output_low(GLCD_E); 
0ABE:  BCF    06.5
0ABF:  BCF    03.5
0AC0:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
0AC1:  BSF    03.5
0AC2:  BCF    06.0
0AC3:  BCF    03.5
0AC4:  BCF    06.0
....................    output_low(GLCD_CS2); 
0AC5:  BSF    03.5
0AC6:  BCF    06.1
0AC7:  BCF    03.5
0AC8:  BCF    06.1
....................    return data;               // Return the read data 
0AC9:  BSF    03.5
0ACA:  MOVF   2E,W
0ACB:  MOVWF  78
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT, HS 
....................  
.................... #byte trisb=0x86 
.................... #byte portb=0x06 
....................  
.................... #byte trisc=0x87 
.................... #byte portc=0x07 
....................  
.................... #byte trisd=0x88 
.................... #byte portd=0x08 
....................  
.................... #byte trise=0x89 
.................... #byte porte=0x09 
....................  
.................... void display_image(void); 
....................  
.................... char PAGE1_TOP[]="STAFF INFO"; 
*
0B68:  MOVLW  53
0B69:  MOVWF  21
0B6A:  MOVLW  54
0B6B:  MOVWF  22
0B6C:  MOVLW  41
0B6D:  MOVWF  23
0B6E:  MOVLW  46
0B6F:  MOVWF  24
0B70:  MOVWF  25
0B71:  MOVLW  20
0B72:  MOVWF  26
0B73:  MOVLW  49
0B74:  MOVWF  27
0B75:  MOVLW  4E
0B76:  MOVWF  28
0B77:  MOVLW  46
0B78:  MOVWF  29
0B79:  MOVLW  4F
0B7A:  MOVWF  2A
0B7B:  CLRF   2B
.................... char PAGE1_BOTTOM[]="APP CTRL"; 
0B7C:  MOVLW  41
0B7D:  MOVWF  2C
0B7E:  MOVLW  50
0B7F:  MOVWF  2D
0B80:  MOVWF  2E
0B81:  MOVLW  20
0B82:  MOVWF  2F
0B83:  MOVLW  43
0B84:  MOVWF  30
0B85:  MOVLW  54
0B86:  MOVWF  31
0B87:  MOVLW  52
0B88:  MOVWF  32
0B89:  MOVLW  4C
0B8A:  MOVWF  33
0B8B:  CLRF   34
....................  
.................... char PAGE2_ECE[]="ECE"; 
0B8C:  MOVLW  45
0B8D:  MOVWF  35
0B8E:  MOVLW  43
0B8F:  MOVWF  36
0B90:  MOVLW  45
0B91:  MOVWF  37
0B92:  CLRF   38
.................... char PAGE2_EEE[]="EEE"; 
0B93:  MOVWF  39
0B94:  MOVWF  3A
0B95:  MOVWF  3B
0B96:  CLRF   3C
.................... char PAGE2_CSC[]="CSC"; 
0B97:  MOVLW  43
0B98:  MOVWF  3D
0B99:  MOVLW  53
0B9A:  MOVWF  3E
0B9B:  MOVLW  43
0B9C:  MOVWF  3F
0B9D:  CLRF   40
.................... char PAGE2_MEK[]="MEK"; 
0B9E:  MOVLW  4D
0B9F:  MOVWF  41
0BA0:  MOVLW  45
0BA1:  MOVWF  42
0BA2:  MOVLW  4B
0BA3:  MOVWF  43
0BA4:  CLRF   44
....................  
.................... char PAGE2A_N1_ECE[]="RAM"; 
0BA5:  MOVLW  52
0BA6:  MOVWF  45
0BA7:  MOVLW  41
0BA8:  MOVWF  46
0BA9:  MOVLW  4D
0BAA:  MOVWF  47
0BAB:  CLRF   48
.................... char PAGE2A_N2_ECE[]="SAM"; 
0BAC:  MOVLW  53
0BAD:  MOVWF  49
0BAE:  MOVLW  41
0BAF:  MOVWF  4A
0BB0:  MOVLW  4D
0BB1:  MOVWF  4B
0BB2:  CLRF   4C
.................... char PAGE2A_N3_ECE[]="MAM"; 
0BB3:  MOVWF  4D
0BB4:  MOVLW  41
0BB5:  MOVWF  4E
0BB6:  MOVLW  4D
0BB7:  MOVWF  4F
0BB8:  CLRF   50
.................... char PAGE2A_N4_ECE[]="HAM"; 
0BB9:  MOVLW  48
0BBA:  MOVWF  51
0BBB:  MOVLW  41
0BBC:  MOVWF  52
0BBD:  MOVLW  4D
0BBE:  MOVWF  53
0BBF:  CLRF   54
....................  
.................... char PAGE2B_N1_EEE[]="RAM1"; 
0BC0:  MOVLW  52
0BC1:  MOVWF  55
0BC2:  MOVLW  41
0BC3:  MOVWF  56
0BC4:  MOVLW  4D
0BC5:  MOVWF  57
0BC6:  MOVLW  31
0BC7:  MOVWF  58
0BC8:  CLRF   59
.................... char PAGE2B_N2_EEE[]="SAM1"; 
0BC9:  MOVLW  53
0BCA:  MOVWF  5A
0BCB:  MOVLW  41
0BCC:  MOVWF  5B
0BCD:  MOVLW  4D
0BCE:  MOVWF  5C
0BCF:  MOVLW  31
0BD0:  MOVWF  5D
0BD1:  CLRF   5E
.................... char PAGE2B_N3_EEE[]="MAM1"; 
0BD2:  MOVLW  4D
0BD3:  MOVWF  5F
0BD4:  MOVLW  41
0BD5:  MOVWF  60
0BD6:  MOVLW  4D
0BD7:  MOVWF  61
0BD8:  MOVLW  31
0BD9:  MOVWF  62
0BDA:  CLRF   63
.................... char PAGE2B_N4_EEE[]="HAM1"; 
0BDB:  MOVLW  48
0BDC:  MOVWF  64
0BDD:  MOVLW  41
0BDE:  MOVWF  65
0BDF:  MOVLW  4D
0BE0:  MOVWF  66
0BE1:  MOVLW  31
0BE2:  MOVWF  67
0BE3:  CLRF   68
....................  
.................... void page1(void); 
.................... void page2(void); 
.................... void page2A(void); 
.................... void pagE2B(void); 
....................  
.................... const int image1[128]={0x00,0x00,0x00,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0xFC,0xFC,0xFC, 
.................... 0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0xFC,0xFC,0xFC,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C, 
.................... 0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x7C,0x7C,0x7C,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70, 
.................... 0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0xF0,0xF0,0xF0,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70, 
.................... 0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70, 
.................... 0x70,0x70,0x70,0x70,0xF0,0xF0,0xF0,0x00,0x00,0x00,0x00,0x00}; 
....................  
....................  
.................... const int image2[128]={0x00,0x00,0xF0,0xF0,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00}; 
....................  
....................  
.................... const int image3[128]={0x00,0x00,0xFF,0xFF,0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0xFF,0xFF,0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80, 
.................... 0x80,0x80,0x80,0x80,0xFF,0xFF,0xFF,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0xFF,0xFF,0xFF,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00}; 
....................  
....................  
.................... const int image4[128]={0x00,0x00,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03, 
.................... 0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x07,0x07,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x1F,0x1F,0x1F,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C, 
.................... 0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00}; 
....................  
....................  
.................... const int image5[128]={0x00,0x00,0x00,0x00,0xF0,0xF0,0xF0,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70, 
.................... 0x70,0x70,0x70,0x70,0x70,0x70,0xF0,0xF0,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xF0,0xF0,0x70,0x70,0x70,0x70, 
.................... 0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70, 
.................... 0x70,0x70,0x70,0x70,0xF0,0xF0,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00}; 
....................  
....................  
.................... const int image6[128]={0x00,0x00,0x00,0x00,0x07,0x07,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00}; 
....................  
....................  
.................... const int image7[128]={0x00,0x00,0x00,0x00,0xF8,0xF8,0xF8,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80, 
.................... 0x80,0x80,0x80,0x80,0x80,0x80,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00}; 
....................  
....................  
.................... const int image8[128]={0x00,0x00,0x00,0x00,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03, 
.................... 0x03,0x03,0x03,0x03,0x03,0x03,0x1F,0x1F,0x1F,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1F,0x0F,0x0F,0x0E,0x0E,0x0E,0x0E, 
.................... 0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E, 
.................... 0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
.................... 0x0F,0x0F,0x0F,0x00,0x00,0x00,0x00,0x00}; 
....................  
....................  
....................  
.................... void main() 
.................... { 
*
0B5B:  CLRF   04
0B5C:  MOVLW  1F
0B5D:  ANDWF  03,F
0B5E:  BSF    03.5
0B5F:  BSF    1F.0
0B60:  BSF    1F.1
0B61:  BSF    1F.2
0B62:  BCF    1F.3
0B63:  MOVLW  07
0B64:  MOVWF  1C
....................  
....................    glcd_init(ON); 
*
0BE4:  MOVLW  01
0BE5:  MOVWF  69
0BE6:  BCF    0A.3
0BE7:  GOTO   6CE
0BE8:  BSF    0A.3
....................    delay_ms(1000); 
0BE9:  MOVLW  04
0BEA:  MOVWF  69
0BEB:  MOVLW  FA
0BEC:  MOVWF  6A
0BED:  BCF    0A.3
0BEE:  CALL   732
0BEF:  BSF    0A.3
0BF0:  DECFSZ 69,F
0BF1:  GOTO   3EB
....................  
....................    display_image(); 
0BF2:  GOTO   000
....................    delay_ms(3000); 
0BF3:  MOVLW  0C
0BF4:  MOVWF  69
0BF5:  MOVLW  FA
0BF6:  MOVWF  6A
0BF7:  BCF    0A.3
0BF8:  CALL   732
0BF9:  BSF    0A.3
0BFA:  DECFSZ 69,F
0BFB:  GOTO   3F5
....................  
....................    //glcd_fillScreen(NO); 
....................  
....................       while(1); 
0BFC:  GOTO   3FC
....................       { 
....................          page1(); 
0BFD:  BCF    0A.3
0BFE:  GOTO   745
0BFF:  BSF    0A.3
....................          delay_ms(2000); 
0C00:  MOVLW  08
0C01:  MOVWF  69
0C02:  MOVLW  FA
0C03:  MOVWF  6A
0C04:  BCF    0A.3
0C05:  CALL   732
0C06:  BSF    0A.3
0C07:  DECFSZ 69,F
0C08:  GOTO   402
....................          glcd_fillScreen(NO); 
0C09:  CLRF   6A
0C0A:  BCF    0A.3
0C0B:  CALL   669
0C0C:  BSF    0A.3
....................  
....................          page2(); 
0C0D:  BCF    0A.3
0C0E:  GOTO   766
0C0F:  BSF    0A.3
....................          delay_ms(2000); 
0C10:  MOVLW  08
0C11:  MOVWF  69
0C12:  MOVLW  FA
0C13:  MOVWF  6A
0C14:  BCF    0A.3
0C15:  CALL   732
0C16:  BSF    0A.3
0C17:  DECFSZ 69,F
0C18:  GOTO   412
....................          glcd_fillScreen(NO); 
0C19:  CLRF   6A
0C1A:  BCF    0A.3
0C1B:  CALL   669
0C1C:  BSF    0A.3
....................  
....................          page2A(); 
0C1D:  BCF    0A.3
0C1E:  GOTO   7A8
0C1F:  BSF    0A.3
....................          delay_ms(2000); 
0C20:  MOVLW  08
0C21:  MOVWF  69
0C22:  MOVLW  FA
0C23:  MOVWF  6A
0C24:  BCF    0A.3
0C25:  CALL   732
0C26:  BSF    0A.3
0C27:  DECFSZ 69,F
0C28:  GOTO   422
....................          glcd_fillScreen(NO); 
0C29:  CLRF   6A
0C2A:  BCF    0A.3
0C2B:  CALL   669
0C2C:  BSF    0A.3
....................  
....................          page2B(); 
0C2D:  GOTO   319
....................          delay_ms(2000); 
0C2E:  MOVLW  08
0C2F:  MOVWF  69
0C30:  MOVLW  FA
0C31:  MOVWF  6A
0C32:  BCF    0A.3
0C33:  CALL   732
0C34:  BSF    0A.3
0C35:  DECFSZ 69,F
0C36:  GOTO   430
....................          glcd_fillScreen(NO); 
0C37:  CLRF   6A
0C38:  BCF    0A.3
0C39:  CALL   669
0C3A:  BSF    0A.3
....................  
....................         /* glcd_line(32, 26, 96, 26, ON); 
....................          glcd_line(96, 26, 96, 38, ON); 
....................          glcd_line(32, 38, 96, 38, ON); 
....................           glcd_line(32, 26, 32, 38, ON); 
....................          //glcd_RECT(32,26,96,34,1,OFF); 
....................          //glcd_pixel(1,1,ON);*/ 
....................  
....................       } 
.................... } 
....................  
.................... void page1(void) 
.................... { 
0C3B:  SLEEP
....................    glcd_text57(10, 10, PAGE1_TOP, 2, ON); DELAY_MS(100); 
*
0745:  MOVLW  0A
0746:  MOVWF  69
0747:  MOVWF  6A
0748:  MOVLW  21
0749:  MOVWF  6B
074A:  MOVLW  02
074B:  MOVWF  6C
074C:  MOVLW  01
074D:  MOVWF  6D
074E:  BSF    0A.3
074F:  CALL   18A
0750:  BCF    0A.3
0751:  MOVLW  64
0752:  MOVWF  6A
0753:  CALL   732
....................    glcd_text57(10, 44, PAGE1_BOTTOM, 2, ON); DELAY_MS(100); 
0754:  MOVLW  0A
0755:  MOVWF  69
0756:  MOVLW  2C
0757:  MOVWF  6A
0758:  MOVWF  6B
0759:  MOVLW  02
075A:  MOVWF  6C
075B:  MOVLW  01
075C:  MOVWF  6D
075D:  BSF    0A.3
075E:  CALL   18A
075F:  BCF    0A.3
0760:  MOVLW  64
0761:  MOVWF  6A
0762:  CALL   732
.................... } 
0763:  BSF    0A.3
0764:  BCF    0A.4
0765:  GOTO   3FF (RETURN)
....................  
.................... void page2(void) 
.................... { 
....................   glcd_text57(10, 10, PAGE2_ECE, 2, ON); DELAY_MS(100); 
0766:  MOVLW  0A
0767:  MOVWF  69
0768:  MOVWF  6A
0769:  MOVLW  35
076A:  MOVWF  6B
076B:  MOVLW  02
076C:  MOVWF  6C
076D:  MOVLW  01
076E:  MOVWF  6D
076F:  BSF    0A.3
0770:  CALL   18A
0771:  BCF    0A.3
0772:  MOVLW  64
0773:  MOVWF  6A
0774:  CALL   732
....................   glcd_text57(80, 10, PAGE2_EEE, 2, ON); DELAY_MS(100); 
0775:  MOVLW  50
0776:  MOVWF  69
0777:  MOVLW  0A
0778:  MOVWF  6A
0779:  MOVLW  39
077A:  MOVWF  6B
077B:  MOVLW  02
077C:  MOVWF  6C
077D:  MOVLW  01
077E:  MOVWF  6D
077F:  BSF    0A.3
0780:  CALL   18A
0781:  BCF    0A.3
0782:  MOVLW  64
0783:  MOVWF  6A
0784:  CALL   732
....................  
....................    glcd_text57(10, 40, PAGE2_CSC, 2, ON); DELAY_MS(100); 
0785:  MOVLW  0A
0786:  MOVWF  69
0787:  MOVLW  28
0788:  MOVWF  6A
0789:  MOVLW  3D
078A:  MOVWF  6B
078B:  MOVLW  02
078C:  MOVWF  6C
078D:  MOVLW  01
078E:  MOVWF  6D
078F:  BSF    0A.3
0790:  CALL   18A
0791:  BCF    0A.3
0792:  MOVLW  64
0793:  MOVWF  6A
0794:  CALL   732
....................    glcd_text57(80, 40, PAGE2_MEK, 2, ON); DELAY_MS(100); 
0795:  MOVLW  50
0796:  MOVWF  69
0797:  MOVLW  28
0798:  MOVWF  6A
0799:  MOVLW  41
079A:  MOVWF  6B
079B:  MOVLW  02
079C:  MOVWF  6C
079D:  MOVLW  01
079E:  MOVWF  6D
079F:  BSF    0A.3
07A0:  CALL   18A
07A1:  BCF    0A.3
07A2:  MOVLW  64
07A3:  MOVWF  6A
07A4:  CALL   732
.................... } 
07A5:  BSF    0A.3
07A6:  BCF    0A.4
07A7:  GOTO   40F (RETURN)
....................  
.................... void page2A(void) 
.................... { 
....................   glcd_text57(10, 10, PAGE2A_N1_ECE, 2, ON); DELAY_MS(100); 
07A8:  MOVLW  0A
07A9:  MOVWF  69
07AA:  MOVWF  6A
07AB:  MOVLW  45
07AC:  MOVWF  6B
07AD:  MOVLW  02
07AE:  MOVWF  6C
07AF:  MOVLW  01
07B0:  MOVWF  6D
07B1:  BSF    0A.3
07B2:  CALL   18A
07B3:  BCF    0A.3
07B4:  MOVLW  64
07B5:  MOVWF  6A
07B6:  CALL   732
....................   glcd_text57(80, 10, PAGE2A_N2_ECE, 2, ON); DELAY_MS(100); 
07B7:  MOVLW  50
07B8:  MOVWF  69
07B9:  MOVLW  0A
07BA:  MOVWF  6A
07BB:  MOVLW  49
07BC:  MOVWF  6B
07BD:  MOVLW  02
07BE:  MOVWF  6C
07BF:  MOVLW  01
07C0:  MOVWF  6D
07C1:  BSF    0A.3
07C2:  CALL   18A
07C3:  BCF    0A.3
07C4:  MOVLW  64
07C5:  MOVWF  6A
07C6:  CALL   732
....................  
....................    glcd_text57(10, 40, PAGE2A_N3_ECE, 2, ON); DELAY_MS(100); 
07C7:  MOVLW  0A
07C8:  MOVWF  69
07C9:  MOVLW  28
07CA:  MOVWF  6A
07CB:  MOVLW  4D
07CC:  MOVWF  6B
07CD:  MOVLW  02
07CE:  MOVWF  6C
07CF:  MOVLW  01
07D0:  MOVWF  6D
07D1:  BSF    0A.3
07D2:  CALL   18A
07D3:  BCF    0A.3
07D4:  MOVLW  64
07D5:  MOVWF  6A
07D6:  CALL   732
....................    glcd_text57(80, 40, PAGE2A_N4_ECE, 2, ON); DELAY_MS(100); 
07D7:  MOVLW  50
07D8:  MOVWF  69
07D9:  MOVLW  28
07DA:  MOVWF  6A
07DB:  MOVLW  51
07DC:  MOVWF  6B
07DD:  MOVLW  02
07DE:  MOVWF  6C
07DF:  MOVLW  01
07E0:  MOVWF  6D
07E1:  BSF    0A.3
07E2:  CALL   18A
07E3:  BCF    0A.3
07E4:  MOVLW  64
07E5:  MOVWF  6A
07E6:  CALL   732
.................... } 
07E7:  BSF    0A.3
07E8:  BCF    0A.4
07E9:  GOTO   41F (RETURN)
....................  
.................... void page2B(void) 
.................... { 
....................   glcd_text57(10, 10, PAGE2B_N1_EEE, 2, ON); DELAY_MS(100); 
*
0B19:  MOVLW  0A
0B1A:  MOVWF  69
0B1B:  MOVWF  6A
0B1C:  MOVLW  55
0B1D:  MOVWF  6B
0B1E:  MOVLW  02
0B1F:  MOVWF  6C
0B20:  MOVLW  01
0B21:  MOVWF  6D
0B22:  CALL   18A
0B23:  MOVLW  64
0B24:  MOVWF  6A
0B25:  BCF    0A.3
0B26:  CALL   732
0B27:  BSF    0A.3
....................   glcd_text57(80, 10, PAGE2B_N2_EEE, 2, ON); DELAY_MS(100); 
0B28:  MOVLW  50
0B29:  MOVWF  69
0B2A:  MOVLW  0A
0B2B:  MOVWF  6A
0B2C:  MOVLW  5A
0B2D:  MOVWF  6B
0B2E:  MOVLW  02
0B2F:  MOVWF  6C
0B30:  MOVLW  01
0B31:  MOVWF  6D
0B32:  CALL   18A
0B33:  MOVLW  64
0B34:  MOVWF  6A
0B35:  BCF    0A.3
0B36:  CALL   732
0B37:  BSF    0A.3
....................  
....................    glcd_text57(10, 40, PAGE2B_N3_EEE, 2, ON); DELAY_MS(100); 
0B38:  MOVLW  0A
0B39:  MOVWF  69
0B3A:  MOVLW  28
0B3B:  MOVWF  6A
0B3C:  MOVLW  5F
0B3D:  MOVWF  6B
0B3E:  MOVLW  02
0B3F:  MOVWF  6C
0B40:  MOVLW  01
0B41:  MOVWF  6D
0B42:  CALL   18A
0B43:  MOVLW  64
0B44:  MOVWF  6A
0B45:  BCF    0A.3
0B46:  CALL   732
0B47:  BSF    0A.3
....................    glcd_text57(80, 40, PAGE2B_N4_EEE, 2, ON); DELAY_MS(100); 
0B48:  MOVLW  50
0B49:  MOVWF  69
0B4A:  MOVLW  28
0B4B:  MOVWF  6A
0B4C:  MOVLW  64
0B4D:  MOVWF  6B
0B4E:  MOVLW  02
0B4F:  MOVWF  6C
0B50:  MOVLW  01
0B51:  MOVWF  6D
0B52:  CALL   18A
0B53:  MOVLW  64
0B54:  MOVWF  6A
0B55:  BCF    0A.3
0B56:  CALL   732
0B57:  BSF    0A.3
.................... } 
0B58:  BSF    0A.3
0B59:  BCF    0A.4
0B5A:  GOTO   42E (RETURN)
....................  
.................... void display_image(void) 
.................... { 
....................    unsigned char count, for_var; 
....................  
....................    for(for_var=0; for_var<8; for_var++) 
*
0800:  CLRF   6A
0801:  MOVF   6A,W
0802:  SUBLW  07
0803:  BTFSS  03.0
0804:  GOTO   16F
....................    { 
....................       output_low(GLCD_DI); 
0805:  BSF    03.5
0806:  BCF    06.2
0807:  BCF    03.5
0808:  BCF    06.2
....................       glcd_writeByte(GLCD_CS1, (0xB8+for_var)); 
0809:  MOVLW  B8
080A:  ADDWF  6A,W
080B:  MOVWF  6B
080C:  MOVLW  30
080D:  BSF    03.5
080E:  MOVWF  30
080F:  BCF    03.5
0810:  MOVF   6B,W
0811:  BSF    03.5
0812:  MOVWF  31
0813:  BCF    0A.3
0814:  BCF    03.5
0815:  CALL   616
0816:  BSF    0A.3
....................       glcd_writeByte(GLCD_CS2, (0xB8+for_var)); 
0817:  MOVLW  B8
0818:  ADDWF  6A,W
0819:  MOVWF  6B
081A:  MOVLW  31
081B:  BSF    03.5
081C:  MOVWF  30
081D:  BCF    03.5
081E:  MOVF   6B,W
081F:  BSF    03.5
0820:  MOVWF  31
0821:  BCF    0A.3
0822:  BCF    03.5
0823:  CALL   616
0824:  BSF    0A.3
....................       glcd_writeByte(GLCD_CS1, 0xC0); 
0825:  MOVLW  30
0826:  BSF    03.5
0827:  MOVWF  30
0828:  MOVLW  C0
0829:  MOVWF  31
082A:  BCF    0A.3
082B:  BCF    03.5
082C:  CALL   616
082D:  BSF    0A.3
....................       glcd_writeByte(GLCD_CS2, 0xC0); 
082E:  MOVLW  31
082F:  BSF    03.5
0830:  MOVWF  30
0831:  MOVLW  C0
0832:  MOVWF  31
0833:  BCF    0A.3
0834:  BCF    03.5
0835:  CALL   616
0836:  BSF    0A.3
....................       output_high(GLCD_DI); 
0837:  BSF    03.5
0838:  BCF    06.2
0839:  BCF    03.5
083A:  BSF    06.2
....................  
....................       for(count=0; count<64; count++) 
083B:  CLRF   69
083C:  MOVF   69,W
083D:  SUBLW  3F
083E:  BTFSS  03.0
083F:  GOTO   0D0
....................       { 
....................          switch(for_var) 
....................          { 
0840:  MOVF   6A,W
0841:  ADDLW  F8
0842:  BTFSC  03.0
0843:  GOTO   0CE
0844:  ADDLW  08
0845:  GOTO   172
....................             case 0:  glcd_writeByte(GLCD_CS1, image1[count]); 
0846:  MOVF   69,W
0847:  BCF    0A.3
0848:  CALL   1EA
0849:  BSF    0A.3
084A:  MOVWF  6B
084B:  MOVLW  30
084C:  BSF    03.5
084D:  MOVWF  30
084E:  BCF    03.5
084F:  MOVF   6B,W
0850:  BSF    03.5
0851:  MOVWF  31
0852:  BCF    0A.3
0853:  BCF    03.5
0854:  CALL   616
0855:  BSF    0A.3
....................             break; 
0856:  GOTO   0CE
....................  
....................             case 1:  glcd_writeByte(GLCD_CS1, image2[count]); 
0857:  MOVF   69,W
0858:  BCF    0A.3
0859:  CALL   271
085A:  BSF    0A.3
085B:  MOVWF  6B
085C:  MOVLW  30
085D:  BSF    03.5
085E:  MOVWF  30
085F:  BCF    03.5
0860:  MOVF   6B,W
0861:  BSF    03.5
0862:  MOVWF  31
0863:  BCF    0A.3
0864:  BCF    03.5
0865:  CALL   616
0866:  BSF    0A.3
....................             break; 
0867:  GOTO   0CE
....................  
....................             case 2:  glcd_writeByte(GLCD_CS1, image3[count]); 
0868:  MOVF   69,W
0869:  BCF    0A.3
086A:  CALL   2F5
086B:  BSF    0A.3
086C:  MOVWF  6B
086D:  MOVLW  30
086E:  BSF    03.5
086F:  MOVWF  30
0870:  BCF    03.5
0871:  MOVF   6B,W
0872:  BSF    03.5
0873:  MOVWF  31
0874:  BCF    0A.3
0875:  BCF    03.5
0876:  CALL   616
0877:  BSF    0A.3
....................             break; 
0878:  GOTO   0CE
....................  
....................             case 3:  glcd_writeByte(GLCD_CS1, image4[count]); 
0879:  MOVF   69,W
087A:  BCF    0A.3
087B:  CALL   37C
087C:  BSF    0A.3
087D:  MOVWF  6B
087E:  MOVLW  30
087F:  BSF    03.5
0880:  MOVWF  30
0881:  BCF    03.5
0882:  MOVF   6B,W
0883:  BSF    03.5
0884:  MOVWF  31
0885:  BCF    0A.3
0886:  BCF    03.5
0887:  CALL   616
0888:  BSF    0A.3
....................             break; 
0889:  GOTO   0CE
....................  
....................             case 4:  glcd_writeByte(GLCD_CS1, image5[count]); 
088A:  MOVF   69,W
088B:  BCF    0A.3
088C:  CALL   400
088D:  BSF    0A.3
088E:  MOVWF  6B
088F:  MOVLW  30
0890:  BSF    03.5
0891:  MOVWF  30
0892:  BCF    03.5
0893:  MOVF   6B,W
0894:  BSF    03.5
0895:  MOVWF  31
0896:  BCF    0A.3
0897:  BCF    03.5
0898:  CALL   616
0899:  BSF    0A.3
....................             break; 
089A:  GOTO   0CE
....................  
....................             case 5:  glcd_writeByte(GLCD_CS1, image6[count]); 
089B:  MOVF   69,W
089C:  BCF    0A.3
089D:  CALL   484
089E:  BSF    0A.3
089F:  MOVWF  6B
08A0:  MOVLW  30
08A1:  BSF    03.5
08A2:  MOVWF  30
08A3:  BCF    03.5
08A4:  MOVF   6B,W
08A5:  BSF    03.5
08A6:  MOVWF  31
08A7:  BCF    0A.3
08A8:  BCF    03.5
08A9:  CALL   616
08AA:  BSF    0A.3
....................             break; 
08AB:  GOTO   0CE
....................  
....................             case 6:  glcd_writeByte(GLCD_CS1, image7[count]); 
08AC:  MOVF   69,W
08AD:  BCF    0A.3
08AE:  CALL   50B
08AF:  BSF    0A.3
08B0:  MOVWF  6B
08B1:  MOVLW  30
08B2:  BSF    03.5
08B3:  MOVWF  30
08B4:  BCF    03.5
08B5:  MOVF   6B,W
08B6:  BSF    03.5
08B7:  MOVWF  31
08B8:  BCF    0A.3
08B9:  BCF    03.5
08BA:  CALL   616
08BB:  BSF    0A.3
....................             break; 
08BC:  GOTO   0CE
....................  
....................             case 7:  glcd_writeByte(GLCD_CS1, image8[count]); 
08BD:  MOVF   69,W
08BE:  BCF    0A.3
08BF:  CALL   58F
08C0:  BSF    0A.3
08C1:  MOVWF  6B
08C2:  MOVLW  30
08C3:  BSF    03.5
08C4:  MOVWF  30
08C5:  BCF    03.5
08C6:  MOVF   6B,W
08C7:  BSF    03.5
08C8:  MOVWF  31
08C9:  BCF    0A.3
08CA:  BCF    03.5
08CB:  CALL   616
08CC:  BSF    0A.3
....................             break; 
08CD:  GOTO   0CE
....................  
....................  
....................          } 
....................       } 
08CE:  INCF   69,F
08CF:  GOTO   03C
....................  
....................       for(count=0; count<64; count++) 
08D0:  CLRF   69
08D1:  MOVF   69,W
08D2:  SUBLW  3F
08D3:  BTFSS  03.0
08D4:  GOTO   16D
....................       { 
....................          switch(for_var) 
....................          { 
08D5:  MOVF   6A,W
08D6:  ADDLW  F8
08D7:  BTFSC  03.0
08D8:  GOTO   16B
08D9:  ADDLW  08
08DA:  GOTO   17E
....................             case 0:  glcd_writeByte(GLCD_CS2, image1[count+64]); 
08DB:  MOVLW  40
08DC:  ADDWF  69,W
08DD:  BCF    0A.3
08DE:  CALL   1EA
08DF:  BSF    0A.3
08E0:  MOVWF  6B
08E1:  MOVLW  31
08E2:  BSF    03.5
08E3:  MOVWF  30
08E4:  BCF    03.5
08E5:  MOVF   6B,W
08E6:  BSF    03.5
08E7:  MOVWF  31
08E8:  BCF    0A.3
08E9:  BCF    03.5
08EA:  CALL   616
08EB:  BSF    0A.3
....................             break; 
08EC:  GOTO   16B
....................  
....................             case 1:  glcd_writeByte(GLCD_CS2, image2[count+64]); 
08ED:  MOVLW  40
08EE:  ADDWF  69,W
08EF:  BCF    0A.3
08F0:  CALL   271
08F1:  BSF    0A.3
08F2:  MOVWF  6B
08F3:  MOVLW  31
08F4:  BSF    03.5
08F5:  MOVWF  30
08F6:  BCF    03.5
08F7:  MOVF   6B,W
08F8:  BSF    03.5
08F9:  MOVWF  31
08FA:  BCF    0A.3
08FB:  BCF    03.5
08FC:  CALL   616
08FD:  BSF    0A.3
....................             break; 
08FE:  GOTO   16B
....................  
....................             case 2:  glcd_writeByte(GLCD_CS2, image3[count+64]); 
08FF:  MOVLW  40
0900:  ADDWF  69,W
0901:  BCF    0A.3
0902:  CALL   2F5
0903:  BSF    0A.3
0904:  MOVWF  6B
0905:  MOVLW  31
0906:  BSF    03.5
0907:  MOVWF  30
0908:  BCF    03.5
0909:  MOVF   6B,W
090A:  BSF    03.5
090B:  MOVWF  31
090C:  BCF    0A.3
090D:  BCF    03.5
090E:  CALL   616
090F:  BSF    0A.3
....................             break; 
0910:  GOTO   16B
....................  
....................             case 3:  glcd_writeByte(GLCD_CS2, image4[count+64]); 
0911:  MOVLW  40
0912:  ADDWF  69,W
0913:  BCF    0A.3
0914:  CALL   37C
0915:  BSF    0A.3
0916:  MOVWF  6B
0917:  MOVLW  31
0918:  BSF    03.5
0919:  MOVWF  30
091A:  BCF    03.5
091B:  MOVF   6B,W
091C:  BSF    03.5
091D:  MOVWF  31
091E:  BCF    0A.3
091F:  BCF    03.5
0920:  CALL   616
0921:  BSF    0A.3
....................             break; 
0922:  GOTO   16B
....................  
....................             case 4:  glcd_writeByte(GLCD_CS2, image5[count+64]); 
0923:  MOVLW  40
0924:  ADDWF  69,W
0925:  BCF    0A.3
0926:  CALL   400
0927:  BSF    0A.3
0928:  MOVWF  6B
0929:  MOVLW  31
092A:  BSF    03.5
092B:  MOVWF  30
092C:  BCF    03.5
092D:  MOVF   6B,W
092E:  BSF    03.5
092F:  MOVWF  31
0930:  BCF    0A.3
0931:  BCF    03.5
0932:  CALL   616
0933:  BSF    0A.3
....................             break; 
0934:  GOTO   16B
....................  
....................             case 5:  glcd_writeByte(GLCD_CS2, image6[count+64]); 
0935:  MOVLW  40
0936:  ADDWF  69,W
0937:  BCF    0A.3
0938:  CALL   484
0939:  BSF    0A.3
093A:  MOVWF  6B
093B:  MOVLW  31
093C:  BSF    03.5
093D:  MOVWF  30
093E:  BCF    03.5
093F:  MOVF   6B,W
0940:  BSF    03.5
0941:  MOVWF  31
0942:  BCF    0A.3
0943:  BCF    03.5
0944:  CALL   616
0945:  BSF    0A.3
....................             break; 
0946:  GOTO   16B
....................  
....................             case 6:  glcd_writeByte(GLCD_CS2, image7[count+64]); 
0947:  MOVLW  40
0948:  ADDWF  69,W
0949:  BCF    0A.3
094A:  CALL   50B
094B:  BSF    0A.3
094C:  MOVWF  6B
094D:  MOVLW  31
094E:  BSF    03.5
094F:  MOVWF  30
0950:  BCF    03.5
0951:  MOVF   6B,W
0952:  BSF    03.5
0953:  MOVWF  31
0954:  BCF    0A.3
0955:  BCF    03.5
0956:  CALL   616
0957:  BSF    0A.3
....................             break; 
0958:  GOTO   16B
....................  
....................             case 7:  glcd_writeByte(GLCD_CS2, image8[count+64]); 
0959:  MOVLW  40
095A:  ADDWF  69,W
095B:  BCF    0A.3
095C:  CALL   58F
095D:  BSF    0A.3
095E:  MOVWF  6B
095F:  MOVLW  31
0960:  BSF    03.5
0961:  MOVWF  30
0962:  BCF    03.5
0963:  MOVF   6B,W
0964:  BSF    03.5
0965:  MOVWF  31
0966:  BCF    0A.3
0967:  BCF    03.5
0968:  CALL   616
0969:  BSF    0A.3
....................             break; 
096A:  GOTO   16B
....................  
....................  
....................          } 
....................       } 
096B:  INCF   69,F
096C:  GOTO   0D1
....................  
....................    } 
096D:  INCF   6A,F
096E:  GOTO   001
.................... } 
096F:  BSF    0A.3
0970:  BCF    0A.4
0971:  GOTO   3F3 (RETURN)
....................  
....................  

Configuration Fuses:
   Word  1: 3FFA   HS NOWDT NOPUT NODEBUG NOPROTECT BROWNOUT LVP NOCPD NOWRT
